# task_04_01 - Минимум 4 чисел

# Напишите функцию min4(a, b, c, d), вычисляющую минимум четырех чисел,
# которая не содержит инструкции if, а использует стандартную функцию min
# от двух чисел. Считайте четыре целых числа и выведите их минимум.

# Вводятся четыре целых числа.
# Выведите ответ на задачу.


def min4(a, b, c, d):
    return min(min(a, b), min(c, d))


a = int(input())
b = int(input())
c = int(input())
d = int(input())

print(min4(a, b, c, d))



# task_04_02 - Длина отрезка

# Даны четыре действительных числа: x₁, y₁, x₂, y₂. Напишите функцию
# distance(x1, y1, x2, y2), вычисляющую расстояниемежду точкой (x₁,y₁)
# и (x₂,y₂). Считайте четыре действительных числа и выведите результат работы
# этой функции.


def distance(x1, y1, x2, y2):
    return ((x1 - x2)**2 + (y1 - y2)**2)**(1/2)


x1 = float(input())
y1 = float(input())
x2 = float(input())
y2 = float(input())

print(distance(x1, y1, x2, y2))



# task_04_03 - Периметр треугольника

# Напишите функцию, вычисляющую длину отрезка по координатам его концов.
# С помощью этой функции напишите программу, вычисляющую периметр треугольника
# по координатам трех его вершин.
#
# На вход программе подается 6 целых чисел — координат x₁, y₁, x₂, y₂, x₃, y₃
# вершин треугольника. Все числа по модулю не превосходят 30 000.
#
# Выведите значение периметра этого треугольника с точностью до 6 знаков после
# десятичной точки.


def distance(x1, y1, x2, y2):
    return ((x1 - x2)**2 + (y1 - y2)**2)**(1/2)


x1 = float(input())
y1 = float(input())
x2 = float(input())
y2 = float(input())
x3 = float(input())
y3 = float(input())

print(distance(x1, y1, x2, y2) +
      distance(x1, y1, x3, y3) +
      distance(x2, y2, x3, y3))



# task_04_04 - Принадлежит ли точка квадрату - 1

# Даны два действительных числа x и y. Проверьте, принадлежит ли точка
# с координатами (x,y) заштрихованному квадрату (включая его границу).
# Если точка принадлежит квадрату, выведите слово YES, иначе выведите
# слово NO. На рисунке сетка проведена с шагом 1.

# Решение должно содержать функцию IsPointInSquare(x, y), возвращающую True,
# если точка принадлежит квадрату и False, если не принадлежит. Основная
# программа должна считать координаты точки, вызвать функцию IsPointInSquare и
# в зависимости от возвращенного значения вывести на экран необходимое
# сообщение.
# Функция IsPointInSquare не должна содержать инструкцию if.


def IsPointInSquare(x, y):
    return (abs(x) <= 1) * (abs(y) <= 1)


x = float(input())
y = float(input())
print(IsPointInSquare(x, y) * "YES" + (1 - IsPointInSquare(x, y)) * "NO")



# task_04_05 - Принадлежит ли точка квадрату - 2

# Даны два действительных числа x и y. Проверьте, принадлежит ли точка
# с координатами(x,y) заштрихованному квадрату (включая его границу). Если
# точка принадлежит квадрату, выведите слово YES, иначе выведите слово NO.
# На рисунке сетка проведена с шагом 1.
#
# Решение должно содержать функцию IsPointInSquare(x, y), возвращающую True,
# если точка принадлежит квадрату и False, если не принадлежит. Основная
# программа должна считать координаты точки, вызвать функцию IsPointInSquare
# и в зависимости от возвращенного значения вывести на экран необходимое
# сообщение.
# Функция IsPointInSquare не должна содержать инструкцию if.


def IsPointInSquare(x, y):
    return (abs(x) <= 1) * (abs(y) <= 1) * (abs(x) + abs(y) <= 1)


x = float(input())
y = float(input())
print(IsPointInSquare(x, y) * "YES" + (1 - IsPointInSquare(x, y)) * "NO")


# task_04_06 - Принадлежит ли точка кругу

# Даны пять действительных чисел: x, y, xc, yc, r.
# Проверьте, принадлежит ли точка (x,y) кругу с центром (xc, yc) и радиусом r.
# Если точка принадлежит кругу, выведите слово YES, иначе выведите слово NO.
#
# Решение должно содержать функцию IsPointInCircle(x, y, xc, yc, r),
# возвращающую True, если точка принадлежит кругу и False, если не принадлежит.
#
# Основная программа должна считать координаты точки, вызвать функцию
# IsPointInCircle и в зависимости от возвращенного значения вывести на экран
# необходимое сообщение. Функция IsPointInCircle не должна содержать
# инструкцию if.


def IsPointInCircle(x, y, xc, yc, r):
    return (x - xc)**2 + (y - yc)**2 <= r**2


x = float(input())
y = float(input())
xc = float(input())
yc = float(input())
r = float(input())
print(IsPointInCircle(x, y, xc, yc, r) * "YES" +
      (1 - IsPointInCircle(x, y, xc, yc, r)) * "NO")


# task_04_07 - Принадлежит ли точка области

# Проверьте, принадлежит ли точка данной закрашенной области.

# Если точка принадлежит области (область включает границы), выведите слово
# YES, иначе выведите слово NO. Решение должно содержать функцию
# IsPntInArea(x, y), возвращающую True, если точка принадлежит области и
# False, если не принадлежит. Основная программа должна считать координаты
# точки, вызвать функцию IsPntInArea и в зависимости от возвращенного
# значения вывести на экран необходимое сообщение. Функция IsPntInArea
# не должна содержать инструкцию if.


def IsPntInAngle(x, y):
    return (y >= -x) * (y >= 2 * x + 2) + (y <= -x) * (y <= 2 * x + 2)


def IsPntInCircle(x, y, xc, yc, r):
    return (y >= 0) * ((x - xc) ** 2 + (y - yc) ** 2 <= r ** 2) + \
           (y < 0) * ((x - xc) ** 2 + (y - yc) ** 2 < r ** 2)


def IsPntInArea(x, y):
    return (y > 0) * IsPntInAngle(x, y) * IsPntInCircle(x, y, -1, 1, 2) + \
           (y < 0) * IsPntInAngle(x, y) * (1 - IsPntInCircle(x, y, -1, 1, 2))


x = float(input())
y = float(input())

ipia = IsPntInArea(x, y)
print(ipia * "YES" + (1 - ipia) * "NO")


# task_04_08 - Исключающее ИЛИ

# Напишите функцию xor(x, y), реализующую функцию "Исключающее ИЛИ"
# двух логических переменных x и y.
#
# Функция xor должна возвращать True, если ровно один из ее аргументов
# x или y, но не оба одновременно равны True.

# Вводится 2 числа - x и y (x и y равны 0 или 1, 0 соответствует значению
# False, 1 соответствует значению True).
# Необходимо вывести 0 или 1 - значение функции от x и y.


def xor(x, y):
    return x * (1 - y) + (1 - x) * y


x = int(input())
y = int(input())

xorxy = xor(x, y)
print(xorxy * True + (1 - xorxy) * False)


# task_04_09 - Минимальный делитель числа

# Дано натуральное число n>1. Выведите его наименьший делитель, отличный от 1.
# Решение оформите в виде функции MinDivisor(n). Алгоритм должен иметь
# сложность порядка корня квадратного из n.
#
# Указание. Если у числа n нет делителя не превосходящего корня из n, то
# число n — простое и ответом будет само число n. А у всех составных чисел
# обязательно есть делители, отличные от единицы и не превосходящие корня из n.


def MinDivisor(n):
    i = 2
    while i <= n**(1/2):
        if n % i == 0:
            return i
        i += 1
    return n


n = int(input())
print(MinDivisor(n))


# task_04_10 - Проверка числа на простоту

# Дано натуральное число n>1. Проверьте, является ли оно простым. Программа
# должна вывести слово YES, если число простое и NO, если число составное.
# Решение оформите в виде функции IsPrime(n), которая возвращает True для
# простых чисел и False для составных чисел. Количество действий в программе
# должно быть пропорционально квадратному корню из n.


def MinDivisor(n):
    i = 2
    while i <= n**(1/2):
        if n % i == 0:
            return i
        i += 1
    return n


def IsPrime(n):
    return MinDivisor(n) == n


n = int(input())
print(IsPrime(n) * "YES" + (1 - IsPrime(n)) * "NO")


# task_04_11 - Возведение в степень

# Дано действительное положительное число a и целое неотрицательное число n.
# Вычислите aⁿ не используя циклы и стандартную функцию pow, а используя
# рекуррентное соотношение aⁿ=a⋅aⁿ⁻¹.
#
# Решение оформите в виде функции power(a, n).


def power(a, n):
    if n == 0:
        return 1
    else:
        return a * power(a, n - 1)


a = float(input())
n = int(input())
print(power(a, n))


# task_04_12 - трицательная степень

# Дано действительное положительное число a и целоe число n. Вычислите aⁿ.
# Решение оформите в виде функции power(a, n). Стандартной функцией
# возведения в степень пользоваться нельзя.


def power(a, n):
    i = 0
    pow = 1
    while i < abs(n):
        i += 1
        pow *= a
    if n < 0:
        pow = 1 / pow
    return pow


a = float(input())
n = int(input())
print(power(a, n))


# task_04_13 - Сложение без сложения

# Напишите рекурсивную функцию sum(a, b), возвращающую сумму двух целых
# неотрицательных чисел. Из всех арифметических операций допускаются только +1
# и -1. Также нельзя использовать циклы.


def sum(a, b):
    if a > 0:
        return sum(a - 1, b) + 1
    if b > 0:
        return sum(a, b - 1) + 1
    else:
        return 0

a = int(input())
b = int(input())
print(sum(a, b))


# task_04_14 - Быстрое возведение в степень

# Возводить в степень можно гораздо быстрее, чем за n умножений!
# Для этого нужно воспользоваться следующими рекуррентными соотношениями:
# aⁿ = (a²)ⁿ/² при четном n, aⁿ=a⋅aⁿ⁻¹ при нечетном n.
# Реализуйте алгоритм быстрого возведения в степень. Если вы все сделаете
# правильно, то сложность вашего алгоритма будет O(logn).
#
# Вводится действительное число a и целое число n.
# Выведите ответ на задачу.


def power(a, n):
    if n < 0:
        return 1 / power(a, -n)
    elif n == 0:
        return 1
    else:
        if n % 2 == 0:
            return power(a**2, abs(n) / 2)
        else:
            return a * power(a, abs(n) - 1)


a = float(input())
n = int(input())
print(power(a, n))


# task_04_15 - Алгоритм Евклида

# Для быстрого вычисления наибольшего общего делителя двух чисел используют
# алгоритм Евклида. Он построен на следующем соотношении: НОД(a,b)=НОД(b,a%b).
#
# Реализуйте рекурсивный алгоритм Евклида в виде функции gcd(a, b).
#
# Вводится два целых числа.
# Выведите ответ на задачу.


def god(a, b):
    if a % b > 0:
        return god(b, a % b)
    else:
        return b


a = int(input())
b = int(input())
print(god(a, b))


# task_04_16 - Сократите дробь

# Даны два натуральных числа n и m. Сократите дробь (n / m), то есть выведите
# два других числа p и q таких, что (n / m) = (p / q) и дробь (p / q) —
# несократимая. Решение оформите в виде функции ReduceFraction(n, m),
# получающая значения n и m и возвращающей кортеж из двух чисел.


def god(a, b):
    if a % b > 0:
        return god(b, a % b)
    else:
        return b


def ReduceFraction(n, m):
    div = god(n, m)
    return n // div, m // div


n = int(input())
m = int(input())
print(ReduceFraction(n, m)[0], ReduceFraction(n, m)[1])


# task_04_17 - Числа Фибоначчи

# Напишите функцию phib(n), которая по данному целому неотрицательному n
# возвращает n-e число Фибоначчи. В этой задаче нельзя использовать циклы -
# используйте рекурсию.


def Fn(n):
    if n >= 3:
        return Fn(n - 1) + Fn(n - 2)
    else:
        return 1


n = int(input())
print(Fn(n))


# task_04_18 - Число сочетаний

# По данным целым числам n и k (0≤k≤n) вычислите C из n по k. Для решения
# используйте рекуррентное соотношение
# C(n,k) = C(n-1,k) + C(n-1,k-1).
#
# Решение оформите в виде функции C(n, k).


def C(n, k):
    if n == 0 or n == 1 or n == k or k == 0:
        return 1
    else:
        return C(n - 1, k) + C(n - 1, k - 1)


n = int(input())
k = int(input())
print(C(n, k))


# task_04_19 - Сумма последовательности

# Дана последовательность целых чисел, завершающаяся числом 0.
# Найдите сумму всех этих чисел, не используя цикл.


def sum(a, b):
    if a != 0:
        return sum(0, b) + a
    if b != 0:
        return sum(a, 0) + b
    return 0


def suminput():
    n = int(input())
    if n != 0:
        return sum(suminput(), n)
    else:
        return 0


sumn = suminput()
# inputn()
print(sumn)


# task_04_20 - Разворот последовательности

# Дана последовательность целых чисел, заканчивающаяся числом 0. Выведите эту
# последовательность в обратном порядке. При решении этой задачи нельзя
# пользоваться массивами и прочими динамическими структурами данных.
# Рекурсия вам поможет.


def inputprint():
    n = int(input())
    if n != 0:  # С While не работает!
        inputprint()
    print(n)

inputprint()


# task_04_21 - Ханойские башни

# Головоломка “Ханойские башни” состоит из трех стержней, пронумерованных
# числами 1, 2, 3. На стержень 1 надета пирамидка из n дисков различного
# диаметра в порядке возрастания диаметра. Диски можно перекладывать с одного
# стержня на другой по одному, при этом диск нельзя класть на диск меньшего
# диаметра. Необходимо переложить всю пирамидку со стержня 1 на стержень 3
# за минимальное число перекладываний.
#
# Напишите программу, которая решает головоломку; для данного числа дисков n
# печатает последовательность перекладываний в формате a b c, где a — номер
# перекладываемого диска, b — номер стержня, с которого снимается данный диск,
# c — номер стержня на который надевается данный диск.
#
# Например, строка 1 2 3 означает перемещение диска номер 1 со стержня 2 на
# стержень 3. В одной строке печатается одна команда. Диски пронумерованы
# числами от 1 до n в порядке возрастания диаметров.
#
# Программа должна вывести минимальный (по количеству произведенных операций)
# способ перекладывания пирамидки из данного числа дисков.
#
# Указание: подумайте, как переложить пирамидку из одного диска? Из двух
# дисков? Из трех дисков? Из четырех дисков? Пусть мы научились перекладывать
# пирамидку из n дисков с произвольного стержня на любой другой, как
# переложить пирамидку из n+1 диска, если можно пользоваться решением
# для n дисков.
#
# Напишите функцию move (n, x, y), которая печатает последовательнось
# перекладываний дисков для перемещения пирамидки высоты n со стержня номер x
# на стержень номер y.
#
# Вводится натуральное число - количество дисков.


def move(n, num, x, y):
    # n - количество перекладываемых дисков, num - номер верхнего диска
    if n == 1:
        print(num, x, y)
    elif n >= 2:
        z = 6 - (x + y)
        move(n - 1, num - 1, x, z)
        move(1, num, x, y)
        move(n - 1, num - 1, z, y)


n = int(input())
move(n, n, 1, 3)


