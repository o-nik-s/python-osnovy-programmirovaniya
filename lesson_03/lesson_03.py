# Неделя 3


# Как устроены вещественные числа
print("Как устроены вещественные числа")

# В отличие от целых чисел, вещественные числа в языке Питон имеют
# ограниченную длину.

# Подумаем, как хранить десятичную дробь в памяти. Поскольку вещественных
# чисел бесконечно много (даже больше, чем натуральных), то нам придется
# ограничить точность. Например, мы можем хранить только несколько первых
# значащих цифр, не храня незначащие нули. Будем отдельно хранить целое число
# с первыми значащами цифрами и отдельно хранить степень числа 10, на которую
# нужно умножить это число.

# Например, число 5.972*10**24 (это масса Земли в килограммах) можно сохранить
# как 5972 (цифры числа, мантисса) и 21 (на какую степень 10 нужно умножить
# число, экспонента). С помощью такого представления можно хранить
# вещественные числа любой размерности.

# Примерно так и хранятся числа в памяти компьютера, однако вместо десятичной
# системы используется двоичные. На большинстве аппаратных систем в языке
# Питон для хранения float используется 64 бита, из которых 1 бит уходит на
# знак, 52 бита - на мантиссу и 11 бит - на экспоненту. Это не совсем правда,
# но достаточно неплохо описывает реальность.

# 53 бита дают около 15-16 десятичных знаков, которые будут хранится точно.
# 11 бит на экспоненту также накладывает ограничения на размерность хранимых
# чисел (примерно от -1000 до 1000 степени числа 10).

# Любое вещественное число на языке Питон представимо в виде дроби, где в
# числителе хранится целое число, а в знаменателе находится какая либо степень
# двойки. Например, 0.125 представимо как 1/8, а 0.1 как
# 3602879701896397/36028797018963968. Несложно заметить, что эта дробь
# не равно 0.1, т.е. хранение числа 0.1 точно в типе float невозможно,
# как и многих других "красивых" десятичных дробей.

# В целом будет полезно представлять себе вещественное число X как отрезок
# [X - epsilon; X + epsilon]. Как же определить величину epsilon?

# Для этого нужно понять, что погрешность не является абсолютной, т.е.
# одинаковой для всех чисел, а является относительной. Упрощенно, аппаратную
# погрешность хранения числа X можно оценить как X*2**(-54).

# Чаще всего в задачах входные данные имеют определенную точность. Рассмотрим
# на примере: заданы два числа X и Y с точностью 6 знаков после точки
# (значит epsilon=5*10**(-7)) и по модулю не превосходящие 10**9. Оценить
# абсолютную погрешность вычисления X * Y. Рассмотрим худший случай, когда
# X и Y равны 10**9 и отклонились на максимально возможное значение epsilon
# в одну сторону. Тогда результат вычисления будет выглядеть так:
# (X + epsilon) * (Y + epsilon) = XY + (X + Y) * epsilon + epsilon**2

# Величина epsilon**2 пренебрежимо мала, XY - это правильный ответ, а
# (X + Y) * epsilon - искомое значение абсолютной погрешности. Подставим числа
# и получим:
# 2 * 10**9 * 5 * 10**(-7) = 10**3

# Абсолютная погрешность вычисления составила 1000 (одну тысячу). Что довольно
# неожиданно и грустно.

# Таким образом, становится понятно, что нужно аккуратно вычислять значение
# погрешности для сравения вещественных чисел.


# Основы работы с вещественными числами
print("Основы работы с вещественными числами")


a = float(input())
b = float(input())
print(a + b)


if 0.1 + 0.2 == 0.3:
    print("Yes")
else:
    print("No")

print(25.0**100)


print('{0:.25f}'.format(0.1))
# 25 - число десятичных знаков после запятой, которое будет выведено
# По умолчанию достаточно вывести 6 или 10 знаков
# В format - то, что мы хотим вывести

# Можно посмотреть на числители и знаменатель дроби, хранящей число
print(0.1.as_integer_ratio())
# Знаменатель /нижнее из чисел/ - степень двойки
print(0.5.as_integer_ratio())
print(0.125.as_integer_ratio())

print(500.0.as_integer_ratio())
print(1.5.as_integer_ratio())

# Любое вещественное число представимо в виде дроби, где в знаменателе стоит
# степень двойки.

print(float(2**100).as_integer_ratio())


print(11 % 2.5)
# Остаток от деления на вещественное число


# Для записи констант или при вводе-выводе может использоваться как привычное
# представление в виде десятично дроби, например 123.456, так и "инженерная"
# запись числа, где мантисса записывается в виде вещественного числа с одной
# цифрой до точки и некоторым количеством цифр после точки, затем следует
# буква ''e'' (или ''E'') и экспонента. Число 123.456 в инженерной записи
# будет выглядеть как 1.23456e2, что означает, что 1.23456 нужно умножить
# на 10**2. И мантисса и экспонента могут быть отрицательными и записываются
# в десятичной системе.

# Такая запись чисел может применяться при создании вещественных констант,
# а также при вводе и выводе. Инженерная запись удобна для хранения очень
# больших или очень маленьких чисел, чтобы не считать количество нулей
# в начале или конце числа.

# Если хочется вывести число не в инженерной записи, а с фиксированным
# количеством знаков после точки, то следует воспользоваться методом format,
# который имеет массу возможностей. Нам нужен только вывод фиксированного
# количества знаков, поэтому воспользуемся готовым рецептом для вывода 25
# знаков после десятичной точки у числа 0.1:
x = 0.1
print('{0:.25f}'.format(x))

# Вывод такой программы будет выглядеть как 0.1000000000000000055511151,
# что еще раз подтверждает мысль о том, что число 0.1 невозможно сохранить
# точно.


# Проблемы вещественных чисел

# Рассмотрим простой пример:
if 0.1 + 0.2 == 0.3:
    print('Yes')
else:
    print('No')

# Если запустить эту программу, то можно легко убедиться в том, что 0.1 + 0.2
# не равно 0.3. Хотя можно было надеятся, что несмотря на неточное
# представление, оно окажется одинаково неточным для всех чисел.

# Поэтому при использовании вещественных чисел нужно следовать нескольким
# простым правилам:

# 1) Если можно обойтись без использования вещественных чисел - нужно это
# сделать. Вещественные числа проблемные, неточные и медленные.
#
# 2) Две вещественных числа равны между собой, если они отличаются не более
# чем на epsilon. Число X меньше числа Y, если X < Y - epsilon.

# Код для сравнения двух чисел, заданных с точностью 6 знаков после точки, выглядит так:
x = float(input())
y = float(input())
epsilon = 5 * 10**-7
if abs(x - y) < 2 * epsilon:
    print('Equal')
else:
    print('Not equal')

# В случае, если над числами совершались какие-то действия, то значения
# epsilon нужно вычислять как в приведенном в первом видео примере.
# В учебных задачах это можно сделать не внутри программы, а один раз руками
# для худшего случая и применять вычисленное значение как константу.


# Округление вещественных чисел

import math # Импорт библиотеки
# В тригонометрии везде используются радианы, а не градусы

from math import floor, ceil, sqrt # Если используем функции часто - импорт функций из библиотеки
# from math import * - Не рекомендуется - Возможен конфликт функций

x1 = 2.5
x2 = 3.5
x3 = -2.5

print(int(x1), int(x2), int(x3))
# int - округляет в сторону нуля - отбрасывает вещественную часть

print(math.floor(x1), math.floor(x2), math.floor(x3))
# floor /пол/ - округление вниз

print(math.ceil(x1), math.ceil(x2), math.ceil(x3))
# ceil /потолок/ - округление вверх

print(round(x1), round(x2), round(x3))
# round - в случае, если 0.5, то округление в сторону ближайшего четного числа

# В библиотеке math также есть функция округления trunc, которая работает аналогично int.

print(math.sqrt(2))


# Срезы строк

# Нам известны способы считывать, выводить и задавать константные строки,
# а также склеивать строки между собой и умножать строку на число.

# len() - определение длин объектов

# Количество символов в строке
# Все строки хранятся в кодировке utf-8, в которой каждый симовл может
# занимать больше 1 байта

# Срез - это способ извлечь из строки отдельные символы или подстроки. При
# применении среза конструируется новая строка, строка, к которой был применён
# срез, остается без изменений.

# Простейший срез: доступ к конкретному символу
# Так, s[i] - iый символ строки s, нумерация идет с нуля
# i - константа, переменная или арифметическое выражение
# Мы можем посмотреть на этот символ, но не можем его изменить
# В Питоне строка - не изменяемый объект
# И какой-то отдельный символ изменить нельзя

# В Питоне есть и нумерация справа-налево отрицательными числами
# Положительная нумерация начинается с нуля и идет дл len()-1
# Отрицательная - с -len() до -1

# Срезы строк
# Позволяют получить подстроки
# s[i:j] возвращает подстроку с iго символа по jый (не включая jый)
# Правая граница в Питоне почти всегда не включается
# Можно использовать положительные и отрицательные индексы вперемешку

# Чтобы брать "с начала" или "до конца" нужно просто ничего не брать вместо индекса

# Третий параметр в срезе задает шаг, по умолчанию равен единице
# Если отрицательный - справа налево
# Второй параметр не включается

# s[:-1] - все символы кроме предпоследнего

# в результате применения среза s[a:b] будет сконструирована подстрока,
# начиная с символа на позиции a и заканчивая символом на позиции b-1
# (правая граница не включается).

# Если в качестве второго числа в срезе взять число, больше либо равное длине
# строки, то ошибки не возникнет и будут взяты все символы до конца строки.


# Использование срезов, метод find

s = 'abcdef'
print(s[0:2])  # Правая граница не включительно
print(s[1:])
print(s[::2])  # Все символы, стоящие на четных местах

# Методы - это таки функции, которые привязаны к объектам
# Методы - это функции, применяемые к объектам. Метод вызывается с помощью
# записи ИмяОбъекта.НазваниеМетода(Параметры). Методы очень похожи на функции,
# но позволяют лучшим образом организовывать хранение и обработку данных.

s = 'abcd abcf abd'
print(s.find('abd'))  # Ищем номер, с которого начинается нужная нам строка
print(s.find('abc'))  # Если несколько вхождений, то выводим первое
print(s.find('ade'))  # -1 - подстрока не входит в строку
# По аналогии со срезами параметры могут быть и отрицательными.

# Также есть модификации с тремя параметрами: они ищут подстроку в срезе s[a:b].

# Хотим найти все вхождения подстроки в строку
pos = 0  # Позиция, начиная с которой мы ищем
while s.find('abc', pos) != -1:
    print(s.find('abc', pos))
    pos = s.find('abc', pos) + 1 # Сдвигаем позицию вправо, иначе бесконечный цикл
    # Т.е. продолжаем поиск со следующей позиции

# Часто возникает задача найти и вывести все вхождения подстроки в строку, включая накладывающиеся.
string = input()
substring = input()
pos = string.find(substring)
while pos != -1:
    print(pos)
    pos = string.find(substring, pos + 1)


# Методы rfind, replace и count

s = 'abcd abcf abd'

# rfind - поиск первого вхождения справа налево
print(s.rfind('abc'))
# У rfind так же есть параметры

# replace заменяет одну подстроку на другую подстроку
print(s.replace('abc', '1234'))
# Не изменяет исходную строку, но возвращает новый объект с заменами
# Третий параметр означает, сколько первых левых вхождений заменить
print(s.replace('abc', '1234', 1))
# У replace нет параметров, с какого по какое вырезать, но можно сделать срез строки,
# внутри сделать replace, а затем вклеить обратно вместе с левым и правым хвостом.

a = 'aaaaaa'
# Мы хотим 2 буквы a заменить на 1 букву a
print(a.replace('aa','a'))
# Замена выполняется только для непересекающихся строк.

# Если хотим заменить все
s = a
while s.find('aa') != -1:
    s = s.replace('aa','a',1)
print(s)

# count позволяет подсчитать количество вхождений подстроки в строку
s = 'abcdefabc'
print(s.count('abc'))
print(s.count('a'))  # Количество вхождений одной буквы
print(s.count('abcd'))
print(s.count('abac'))  # Если строка вообще не входит, то получаем ноль

s = 'aaaaaa'
print(s.count('aa'))
# count проверяет вхождения не пересекающихся подстрок
# Параметр end - не включителен
print(s.count('aa',1))


# Метод rfind работает аналогично find, но ищет самое правое вхождение.
#
# Метод replace(old, new) позволяет заменить все вхождения подстроки old
# на подстроку new. При этом конструируется новая строка, где были произведены
# замены. Нужно обратить внимание, что метод replace заменяет вхождения
# подстрок без учета предыдущих совершенных замен. Если применить следующую
# операцию 'AAAAAA'.replace('AA', 'A'), то в результате получится
# строка 'AAA', а не 'A', как можно было бы ожидать.
#
# Фактически, можно считать, что метод replace находит очередное вхождение
# подстроки old, осуществляет замену и продолжает поиск с позиции после всех
# заменненных символов (без наложения и поиска в свежезамененной части).
#
# Существует модификация replace(old, new, count), которая осуществляет не
# более count замен самых левых вхождений подстроки old.
#
# Также для строк существует метод count, который позволяет подсчитать
# количество вхождений подстроки. По аналогии с методом find определены методы
# count с двумя и тремя параметрами.

