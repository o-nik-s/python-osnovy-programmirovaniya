# Определение методов и стандартные функции

# Фактически когда Вы вызываете функцию print() для некоторого объекта, на самом деле вызывается нечтоподобное
# функции str() для этого объекта.
# Но на самом деле функция str, в свою очередь, является всего лишь оберткой над стандартным методом,
# который определен у всех стандартных объектов и который мы можем определить для своего объекта.
# Этот метод называется подчеркивание, подчеркивание str (__str).

# То есть на самом деле, когда вы вызовете str от чего угодно, то произойдет всего лишь вызов метода __str__ для этого объекта.

#  Никаких параметров он не принимает, то есть единственный его параметр — это self, сам объект, это обязательно,
# и нам нужно вернуть строковое представление объекта.

class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im

    def __str__(self):
        return str(self.re) + "+" + str(self.im) + "i"

a = Complex(1, 2)
b = Complex(3)
c = Complex()
print(a)
print(b)
print(c)
print(str(a), str(b), str(c))
print()

# Вот теперь функция str стандартная, научилась давать строковое представление нашего объекта.
# Если бы у нас не было объектно-ориентированного программирования, то нам пришлось бы лезть куда-то
# в стандартную библиотеку и там переписывать функцию str, которую нам должны были дать, этот исходный код,
# каким-то образом, что, вообще говоря, не всегда возможно, чтобы научить ее работать с нашим типом объекта.
# Но когда у нас str — всего лишь обертка над методом класса, все это делается легко и непринужденно,
# и ни в какие стандартные библиотеки мы не залезаем.


#  Давайте посмотрим, какие еще методы можно определить.

#  В Python очень много стандартных разных методов. Например, плюс определен для многих объектов — для строк, для чисел,
# и мог бы быть определен для каких-нибудь кортежей или списков, если бы это имело какой-то смысл. Часть объектов,
# которые вы будете использовать, имеет логичную операцию «плюс». Для комплексных чисел, как для математических объектов,
# операция «плюс» вообще однозначно определена, и математики такой записью пользуются, и поэтому мы можем ее сделать.
# Давайте сначала сделаем, потом я расскажу, когда не стоит так поступать.

# Итак, метод, опять же, с этими подчеркиваниями, add — «добавить». Что он должен принимать? Он должен принимать self —
# себя, как и все методы, и еще один параметр — other. То есть что это такое? Это наш объект, и второй объект,
# с которым будем складывать того же самого типа комплексное число. Результатом должен быть новый объект, то есть
# мы не меняем self, а возвращаем новый объект. Почему? Потому что когда вы пишете, например, a = 2 + 3, вы ожидаете,
# что в переменной a создастся новое число, равное 5, а не двойка превратится в пятерку. Вот и здесь такая же логика,
# то есть мы не меняем слагаемые, а создаем новый объект с результатом.


class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im

    def __str__(self):
        return str(self.re) + "+" + str(self.im) + "i"

    def __add__(self, other):
        result = Complex(self.re + other.re, self.im + other.im)
        return result

a = Complex()
b = Complex(1, 4)
c = Complex(2, 3)
print(b + c)
# print(b + 1) # AttributeError: 'int' object has no attribute 're'
# То есть автоматически у вас ваше целое число не превратится в комплексное. Если вы хотите складывать с целым числом,
# то, например, вы должны вызывать конструктор от этого целого числа, и его действительная часть попадет в поле re,
# а im будет равно нулю, и вы получите то, что нужно.
print(b + Complex(1))
print()


# Теперь давайте посмотрим, как делается умножение. mul, multiplication, точно так же два параметра, само наше число,
# сам объект, и второй объект того же типа.

class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im

    def __str__(self):
        return str(self.re) + "+" + str(self.im) + "i"

    def __add__(self, other):
        result = Complex(self.re + other.re, self.im + other.im)
        return result

    def __mul__(self, other):
        re = self.re * other.re - self.im * other.im
        im = self.re * other.im + self.im * other.re
        return Complex(re, im)

a = Complex()
b = Complex(1, 4)
c = Complex(2, 3)
print(b * c)
# Вот эти re и im, которые мы создали внутри метода, это локальные переменные, то есть они не являются полями
# какого-то объекта, ни self и ни other, это просто локальные переменные внутри метода.

# Даже если ваш объект имеет не математический какой-то смысл, может быть, вы хотите определить операцию умножения
# описания человека на описание другого человека. Это, конечно, сделать можно, но любая замена стандартной операции
# должна иметь однозначный, понятный для человека смысл.


'''Некоторые стандартные функции языка Питон являются всего-лишь обертками над вызовом метода для передаваемого параметра. 
Например, функция str вызывает метод __str__ для своего параметра. Если мы опишем такой метод для нашего класса, 
то можно будет применять к нему функцию str явно и неявно (например, она автоматически вызовется при вызове print 
для объекта нашего класса).

Мы бы хотели, чтобы __str__ возвращал текстовое представление нашего комплексного числа. Например, число 
с действительной частью 1 и мнимой 2 должно быть представлено в виде строки ''1+2i'', а число с действительной частью 3 
и мнимой -4.5 - как ''3-4.5i''. Полное описание класса с добавленным методом будет выглядеть так:'''
class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im

    def __str__(self):
        strRep = str(self.re)
        if self.im >= 0:
            strRep += '+'
        strRep += str(self.im) + 'i'
        return strRep


a = Complex(1, 2)
print(a)
b = Complex(3, -4.5)
print(b)


'''Переопределение операторов

В языке Питон можно переопределить и поведение операторов. Например, если у нас есть два числа x и y, 
то запись x + y реально преобразуется в вызов метода x.__add__(y). Значок операции + является всего лишь 
удобным для человека переопределением вызова метода add.

Для вещественных чисел логично определена операция сложения: это сложение отдельно действительных и отдельно 
мнимых частей. В результате вызова метода для сложения двух чисел должен конструироваться новый объект класса Complex, 
а переданные в качестве параметров объекты не должны изменяться. Действительно, когда мы выполняем операция z = x + y 
для обычных чисел, то ожидаем, что сконструируется новый объект, к которому привяжется ссылка z, а x и y 
останутся без изменения.

Будем придерживаться этой же логики при реализации метода для сложения двух комплексных чисел. Наш метод __add__ 
должен принимать два параметра, каждый из которых является комплексным числом.'''
class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im

    def __str__(self):
        strRep = str(self.re)
        if self.im >= 0:
            strRep += '+'
        strRep += str(self.im) + 'i'
        return strRep

    def __add__(self, other):
        newRe = self.re + other.re
        newIm = self.im + other.im
        return Complex(newRe, newIm)


a = Complex(1, 2)
b = Complex(3, -4.5)

'''Переопределять метод add имеет смысл только в тех ситуациях, когда программисту, использующему ваш класс, 
будет очевиден смысл операции +. Например, если бы вы создали класс для описание некоторых характеристик человека, 
то операция + для двух объектов-людей воспринималась разными пользователями вашего класса совершенно по-разному, 
в зависимости от развитости фантазии читателя. Такого неоднозначного понимания лучше избегать и вовсе не переопределять 
операцию +, если результат её работы не очевиден.'''
