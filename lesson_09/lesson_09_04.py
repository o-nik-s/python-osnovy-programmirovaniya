# Проверка класса объекта

# Когда мы пишем значок * между двумя объектами каких-то классов, то у нас вызывается на самом деле метод умножения,
# описанный как __mul__.

# Допустим, мы хотим научиться умножать комплексное число не только на другое комплексное число, но и, например,
# на целое или вещественное число.

class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im

    def __str__(self):
        return str(self.re) + "+" + str(self.im) + "i"

    def __add__(self, other):
        result = Complex(self.re + other.re, self.im + other.im)
        return result

    def __mul__(self, other):
        if isinstance(other, Complex): # Проверка принадлежности объекта классу
            re = self.re * other.re - self.im * other.im
            im = self.re * other.im + self.im * other.re
        elif isinstance(other, int) or isinstance(other, float):
            re = self.re * other
            im = self.im * other
        return Complex(re, im)

    __rmul__ = __mul__
    # def __rmul__(self, other):
    #    return self * other

a = Complex()
b = Complex(1, 4)
c = Complex(2)
print(2 * b)

# isinstance(other, Complex) позволяет проверить, является ли у нас объект представителем некоторого класса.
# При этом, конечно, можно было в данном случае сделать немножко по-другому — определить тип объекта (для этого
# есть стандартная функция Type) и сравнить его с комплексным числом — но isinstance немного другой смысл имеет.

# Когда мы пишем операцию * в смысле умножение, у нас вызывается метод умножения для того объекта, для того класса
# описанный, который стоит слева от умножения.

# Есть операция rmul — правое умножение. В принципе, значит, self и other будут иметь тот же смысл, то есть
# на место self будет подставляться объект типа комплекс, оно переставляет параметры. rmul вызывается в случае,
# если не получилось вызвать mul для левого объекта,

# Мы можем, напомню, в Python любой объект присвоить любому объекту.

# И мы создаем объект rmul — метод, функцию, по сути, которая равна другой функции. Все, теперь у нашей функции
# два имени. И когда мы будем вызывать rmul, реально будет вызываться обычный mul, multiplication.


'''В языке Питон существует функция isinstance, которая в качестве первого параметра принимает объект, 
а в качестве второго - название класса. Она возвращает истину, если объект относится к данному классу 
и ложь в противном случае. Эта функция позволит нам добиться нужной функциональности от метода __mul__, 
умножающего числа.'''


class Complex:
    def __init__(self, re=0, im=0):
        self.re = re
        self.im = im

    def __str__(self):
        strRep = str(self.re)
        if self.im >= 0:
            strRep += '+'
        strRep += str(self.im) + 'i'
        return strRep

    def __add__(self, other):
        newRe = self.re + other.re
        newIm = self.im + other.im
        return Complex(newRe, newIm)

    def __mul__(self, other):
        if isinstance(other, Complex):
            newRe = self.re * other.re - self.im * other.im
            newIm = self.re * other.im + self.re * other.im
        elif isinstance(other, int) or isinstance(other, float):
            newRe = self.re * other
            newIm = self.im * other
        return Complex(newRe, newIm)

    __rmul__ = __mul__


a = Complex(1, 2)
b = Complex(3, -4.5)
print(a * b)
print(a * 2)


'''Кроме добавленного метода __mul__ внимания также заслуживает строка __rmul__ = __mul__. Это присваивание одного метода 
(функции) другому, т.е. при вызове метода __rmul__ будет вызываться тот же самый метод __mul__.

В языке питон операция a * b заменяется на вызов метода a.__mul__(b). Если a было комплексным числом, а b - вещественным, 
то вызовется метод __mul__ для объекта a нашего класса Complex.

Однако, если a было вещественным числом, а b - комлексным, то произойдет попытка вызвать метод __mul__ для объекта класса 
float. Естественно, разработчики стандартной библиотеки языка Питон не могли предположить, что вы когда-нибудь напишите 
класс Complex и будете пытаться умножить на него вещественное число, поэтому метод __mul__, где в качестве параметра 
передается нечто неизвестное, будет заканчивать свою работу с ошибкой. Чтобы избежать таких ситуаций в языке Питон 
после неудачной попытки совершить a.__mul__(b) просходит попытка совершить действие b.__rmul__(a) и в нашем случае 
она заканчивается успехом.'''


