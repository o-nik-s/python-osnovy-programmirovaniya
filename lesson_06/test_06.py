

# Теперь посмотрим на еще одну довольно специфическую задачу, а именно — посортировать данные,
# которые могут принимать, каждый элемент может принимать очень небольшое количество значений.
# Например, оценки в «Вышке» бывают от нуля то десяти. И человек получил какой-то список оценок,
# мы хотим их упорядочить.

# Понятное дело, что мы можем просто взять и воспользоваться сортировкой. Но иногда, и не только
# для задач сортировки, применим классный метод, который называется «сортировка подсчетом». А именно,
# мы будем считать, сколько и каких оценок человек получил.

myList = list(map(int, input().split()))
grades = [0] * 11  # Числа от 0 до 10 - всего их 11 штук. Т.е. сначала у человека 0 оценок каждого типа
# Индекс в этом списке будет задавать оценку, а значение будет обозначать количество таких оценок
for now in myList:
    grades[now] +=  1
print(grades)
for grade in range(len(grades)):
    for i in range(grades[grade]):
        print(grade, end=' ')
    # print((str(grade) + ' ') * grades[grade], end=" ")

# Вот эта штука называется «сортировка подсчетом». Она используется не только для сортировки,
# для многих других задач. И, наверное, когда вы увидите какую-то задачу, где очень небольшое
# количество возможных значений, вспомните о таком методе. Ну, например, посчитать количество букв,
# которые встречаются в тексте, или еще что-нибудь в этом духе.


# В принципе сортировка может быть применена для поиска минимума или максимума последовательности,
# но делать так не стоит.
myList = list(map(int, input().split()))
myList.sort()
print(myList[0])

# Сортировка - это достаточно длинная операция. Она работает за n*log(n) операций. В то же время
#  просто пройти по списку, сделать линейный поиск мы можем за n операций, то есть просто
# посмотрев один раз на каждый элемент.


# Если у вас какая-то более сложная задача, например, второй по величине элемент нужно найти,
# то стандартной функции для этого нет, и пользоваться или не пользоваться сортировкой уже
# вопрос достаточно тонкий. Почему? Потому что понятное дело, когда вы ищете второй минимум,
# вы тоже можете это сделать за один проход по массиву, просто воспользовавшись циклом for.
# Если же вы воспользуетесь сортировкой, то вы потратите n * log(n) действий, что несколько больше,
# но вся ирония заключается в том, что в Python стандартные функции работают намного быстрее,
# чем что бы то ни было, написанное непосредственно на Python. Поэтому может оказаться так,
# что вы, конечно, написали очень эффективный линейный алгоритм поиска, но сортировка в реальности
# будет работать лучше. Поэтому вопрос это сложный, но знать о том, что необязательно использовать
# сортировку для таких вещей, конечно же, нужно.
