# Гражданская оборона

# Штаб гражданской обороны Тридесятой области решил обновить план спасения
# на случай ядерной атаки. Известно, что все n селений Тридесятой области
# находятся вдоль одной прямой дороги. Вдоль дороги также расположены
# m бомбоубежищ, в которых жители селений могут укрыться на случай
# ядерной атаки.
#
# Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
# необходимо для каждого селения определить ближайшее к нему бомбоубежище.
#
# В первой строке вводится число n - количество селений (1 <= n <= 100000).
# Вторая строка содержит n различных целых чисел, i-е из этих чисел задает
# расстояние от начала дороги до i-го селения. В третьей строке входных данных
# задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая
# строка содержит m различных целых чисел, i-е из этих чисел задает расстояние
# от начала дороги до i-го бомбоубежища. Все расстояния положительны и
# не превышают 10⁹. Селение и убежище могут располагаться в одной точке.
#
# Выведите n чисел - для каждого селения выведите номер ближайшего к нему
# бомбоубежища. Бомбоубежища пронумерованы от 1 до m в том порядке, в котором
# они заданы во входных данных.

# Указание
#
# Создайте список кортежей из пар (позиция селения, его номер в исходном
# списке), а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.
#
# Перебирайте селения в порядке возрастания.
#
# Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо
# выбрать ближайшее. При переходе к следующему селению не обязательно искать
# ближайшее бомбоубежище с самого начала. Его можно искать начиная с позиции,
# найденной для предыдущего города.
#
# Для хранения ответа используйте список, где индекс будет номером селения, а
# по этому индексу будет запоминаться номер бомбоубежища.

n = int(input())
distn = list(map(int, input().split()))
m = int(input())
distm = list(map(int, input().split()))

listn = [[distn[i], i] for i in range(len(distn))]
listm = [[distm[i], i] for i in range(len(distm))]
listn.sort()
listm.sort()

listnm = [0 for i in range(n)]
j = 0  # Перебираем убежища
for place in listn:  # Перебираем селения
    while j < len(listm) and place[0] > listm[j][0]:
        j += 1
    if j < len(listm) and abs(listm[j - 1][0] - place[0]) <= \
            abs(listm[j][0] - place[0]) or j >= len(listm):
        listnm[place[1]] = listm[j - 1][1]
    else:
        listnm[place[1]] = listm[j][1]
for i in range(len(listnm)):
    listnm[i] = listnm[i] + 1
print(*listnm)
