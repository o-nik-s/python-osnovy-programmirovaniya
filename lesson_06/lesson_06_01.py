# Сортировка. Сравнение списков и кортежей

# Сортировать: упорядочить

# В Питоне по умолчанию данные упорядочиваются по неубыванию.


a = [3, 1, 2]
a.sort()
print(*a)

# Метод sort изменяет содержимое списка - после применения метода sort элементы в списке
# становятся упорядоченными. Такой метод определен только для объектов типа список,
# его нельзя применить к кортежу или iterable или строке.


# Если метод sort изменяет список, то функция sorted создает отсортированную копию, не изменяя список.

a = [3, 1, 2]
b = sorted(a)
print(*a)

# sorted разумно использовать только в ситуации, когда нужно сохранить исходную последовательность

# sorted умеет работать не только со списками, но и получать на вход что угодно итерируемое,
# может получать на вход строку или даже кортеж. При этом результатом работы всегда является список.

b = sorted(range(12, 0, -1))
print(*b)

b = sorted('edcba')
print(*b)

b = sorted([5, 4, 3, 2, 1])
print(*b)

# Можно сделать именованный параметр в функции sorted и методе sort: reverse = True - если нужно развернуть список

a = [3, 1, 2]
b = sorted(a, reverse = True)
print(*b)

# Можно сортировать и более сложные объекты, такие как кортежи или списки.
print((1, 2) < (3, 4)) # Сравниваем кортежи
# Это работает так же как строки - сравнение происходит поэлементно
# Сначала сравниваем нулевые строки. Если они не равны, то уже понятно, какой из кортежей меньше.
# Если же они равны, то сравнение будет происходить по следующим элементам
# Если один из кортежей закончился, а другой - нет, то меньше тот, который закончился

# Сортировку можно применять к спискам, все элементы которых сравнимы между собой.
# Обычно это однородные списки (состоящие из элементов одного типа) или, в редких случаях,
# целые и вещественные числа вперемешку.

# Кортеж может содержать в себе что угодно в качестве элементов, т.е. быть смешанным
# Если сравниваем кортежи с разными элементами, то может произойти ошибка
# print((1, 2) < (1, 'a')) # Ошибка!
print((1, 2) < (2, 'a')) # Работает
# Cравниваемые кортежи или списки должны содержать на соответствующих позициях сравнимые элементы

# Списки можно сравнивать между собой так же как и кортежи, т.е. элементы сравниваются до тех пор,
# пока не найдутся различные.

# Пусть есть следующая задача
# Упорядочить людец по росту, при этом для каждого человека известны его рост и имя. Т.е. если рост одинаковый,
# будем упорядочивать его по имени.

# Каждого человека опишем в виде кортежа: рост, имя
p = [(172, 'Vasya'),
     (180, 'Petya'),
     (172, 'Fedya')]
p.sort()
print(*p)
# Пробел меньше, чем любая из букв

# Пусть хотим отсоритовать по убыванию роста, но внутри по имени - в алфавитном порядке
p = [(172, 'Vasya'),
     (180, 'Petya'),
     (172, 'Fedya')]
p.sort(reverse=True)
print(*p) # Развернул и по имени тоже. Это не совсем то, что нужно


# lesson_06_02 и lesson_06_03


# Сортировка подсчетом

# Сейчас мы посмотрим не на новые конструкции языка Python, а на некоторые, по сути, алгоритмы и приемы работы с данными.

# Во многих задачах необходимо не просто отсортировать данные, а запомнить, на каком месте они стояли
# в исходной последовательности. Давайте, собственно, и решим такую задачу, а именно: сказать, на каких позициях
# в исходной последовательности стояли элементы, так чтобы, если мы их передставим так, как у нас будет вывод,
# они оказались упорядочены. То есть отсортировать числа с их номерами.

myList = list(map(int, input().split()))
newList = []
for i in range(len(myList)):
    newList.append((myList[i], i))
newList.sort()
print(newList)

# Во-первых, это список кортежей — в каждом кортеже у нас сначала стоит число,
# какое было оно в списке, а затем его позиция при нумерации с нуля в исходном списке

# И если нам нужно распечатать только позиции, мы можем, опять же, это сделать очень
# похожим способом, перебрав все элементы уже. Перебрав все элементы нового списка с кортежей
# и напечатав только их первые индексы с кортежа, то есть как раз номера.

myList = list(map(int, input().split()))
newList = []
for i in range(len(myList)):
    newList.append((myList[i], i)) # Добавляем кортеж!
newList.sort()
for now in newList:
    print(now[1])

# У нас напечаталось, что самый маленький элемент стоял на первом месте в списке — да,
# это похоже на правду, следующий по величине — на нулевом месте, затем на втором и на третьем.

# Вот, такое сопоставление числа и его номера в исходной последовательности пригодится
# вам при решении задач, и по жизни это тоже бывает нужно.



# Теперь посмотрим на еще одну довольно специфическую задачу, а именно — посортировать данные,
# которые могут принимать, каждый элемент может принимать очень небольшое количество значений.
# Например, оценки в «Вышке» бывают от нуля то десяти. И человек получил какой-то список оценок,
# мы хотим их упорядочить.

# Понятное дело, что мы можем просто взять и воспользоваться сортировкой. Но иногда, и не только
# для задач сортировки, применим классный метод, который называется «сортировка подсчетом». А именно,
# мы будем считать, сколько и каких оценок человек получил.

myList = list(map(int, input().split()))
grades = [0] * 11  # Числа от 0 до 10 - всего их 11 штук. Т.е. сначала у человека 0 оценок каждого типа
# Индекс в этом списке будет задавать оценку, а значение будет обозначать количество таких оценок
for now in myList:
    grades[now] +=  1
print(grades)
for grade in range(len(grades)):
    for i in range(grades[grade]):
        print(grade, end=' ')
    # print((str(grade) + ' ') * grades[grade], end=" ")

# Вот эта штука называется «сортировка подсчетом». Она используется не только для сортировки,
# для многих других задач. И, наверное, когда вы увидите какую-то задачу, где очень небольшое
# количество возможных значений, вспомните о таком методе. Ну, например, посчитать количество букв,
# которые встречаются в тексте, или еще что-нибудь в этом духе.


# В принципе сортировка может быть применена для поиска минимума или максимума последовательности,
# но делать так не стоит.
myList = list(map(int, input().split()))
myList.sort()
print(myList[0])

# Сортировка - это достаточно длинная операция. Она работает за n*log(n) операций. В то же время
#  просто пройти по списку, сделать линейный поиск мы можем за n операций, то есть просто
# посмотрев один раз на каждый элемент.


# Если у вас какая-то более сложная задача, например, второй по величине элемент нужно найти,
# то стандартной функции для этого нет, и пользоваться или не пользоваться сортировкой уже
# вопрос достаточно тонкий. Почему? Потому что понятное дело, когда вы ищете второй минимум,
# вы тоже можете это сделать за один проход по массиву, просто воспользовавшись циклом for.
# Если же вы воспользуетесь сортировкой, то вы потратите n * log(n) действий, что несколько больше,
# но вся ирония заключается в том, что в Python стандартные функции работают намного быстрее,
# чем что бы то ни было, написанное непосредственно на Python. Поэтому может оказаться так,
# что вы, конечно, написали очень эффективный линейный алгоритм поиска, но сортировка в реальности
# будет работать лучше. Поэтому вопрос это сложный, но знать о том, что необязательно использовать
# сортировку для таких вещей, конечно же, нужно.


'''Связь задач поиска и сортировки

Во многих задачах линейного поиска (например, поиск минимального элемента) возникает соблазн 
воспользоваться сортировкой.

С этим соблазном следует бороться, т.к. сложность сортировки в языке Питон составляет O(NlogN), 
т.е. для сортировки списка из N элементов нужно совершить порядка NlogN действий.

При этом алгоритмы линейного поиска работают за O(N), что асимптотически быстрее, чем сортировка. 
Поэтому в задачах линейного поиска (даже для поиска третьего по величине элемента) следует реализовывать 
линейный поиск, а не пользоваться сортировкой.

По иронии судьбы, сортировка в интерпретаторе CPython может оказаться быстрее рукописного линейного поиска 
(из-за того, что она реализовано максимально эффективно и на языке Си). Но это досадное недоразумение не должно 
побороть в вас желание писать линейный поиск руками.'''


