# task_06_01 - Слияние списков

# Даны два списка A и B упорядоченных по неубыванию. Объедините их в один
# упорядоченный список С (то есть он должен содержать len(A)+len(B)
# элементов). Решение оформите в виде функции merge(A, B), возвращающей
# новый список. Алгоритм должен иметь сложность O(len(A)+len(B)).
# Модифицировать исходные списки запрещается. Использовать функцию
# sorted и метод sort запрещается.


def merge(A, B):
    i, j, k = 0, 0, 0
    C = [0 for k in range(len(A) + len(B))]
    while i < len(A) or j < len(B):
        if i < len(A) and j < len(B):
            if A[i] <= B[j]:
                C[k] = A[i]
                i += 1
            else:
                C[k] = B[j]
                j += 1
        elif i >= len(A):
            C[k] = B[j]
            j += 1
        elif j >= len(B):
            C[k] = A[i]
            i += 1
        k += 1
    return C


A = list(map(int, input().split()))
B = list(map(int, input().split()))
print(" ".join(map(str, merge(A, B))))


# task_06_02 - Пересечение множеств

# Даны два списка, упорядоченных по возрастанию (каждый список состоит
# из различных элементов).
#
# Найдите пересечение множеств элементов этих списков, то есть те числа,
# которые являются элементами обоих списков. Алгоритм должен иметь
# сложность O(len(A)+len(B)).
#
# Решение оформите в виде функции Intersection(A, B). Функция должна
# возвращать список пересечения данных списков в порядке возрастания
# элементов. Модифицировать исходные списки запрещается.


def Intersection(A, B):
    C = [0 for i in range(len(A) + len(B))]
    i, j, k = 0, 0, 0
    while i <= len(A) - 1 and j <= len(B) - 1:
        if A[i] == B[j]:
            if k == 0 or k > 0 and A[i] != C[k-1]:
                C[k] = A[i]
                k += 1
            i += 1
            j += 1
        elif A[i] < B[j]:
            i += 1
        elif A[i] > B[j]:
            j += 1
    i = len(C) - 1
    while i >= 0 and C[i] == 0:
        C.pop()
        i -= 1
    if 0 in A and 0 in B and A[len(A) - 1] == 0:
        C.append(0)
    return C


A = list(map(int, input().split()))
B = list(map(int, input().split()))
print(" ".join(map(str, Intersection(A, B))))


# task_06_03 - Сортировка

# Отсортируйте данный массив, используя встроенную сортировку.
#
# Первая строка входных данных содержит количество элементов в массиве N,
# N ≤ 10⁵. Далее идет N целых чисел, не превосходящих
# по абсолютной величине 10⁹.
#
# Выведите эти числа в порядке неубывания.

N = int(input())
lst = list(map(int, input().split()))
lst.sort()
print(*lst)


# task_06_04 - Обувной магазин

# В обувном магазине продается обувь разного размера. Известно, что одну пару
# обуви можно надеть на другую, если она хотя бы на три размера больше.
# В магазин пришел покупатель.Требуется определить, какое наибольшее
# количество пар обуви сможет предложить ему продавец так, чтобы он смог
# надеть их все одновременно.
#
# Сначала вводится размер ноги покупателя (обувь меньшего размера он надеть
# не сможет), в следующей строке — размеры каждой пары обуви в магазине
# через пробел. Размер — натуральное число, не превосходящее 100.
#
# Выведите единственное число — максимальное количество пар обуви, которое
# сможет надеть покупатель.

size = int(input())
sizes = list(map(int, input().split()))
sizes.sort()
i = 0
while i < len(sizes) and sizes[i] < size:
    i += 1
count = 0
while i < len(sizes):
    if size <= sizes[i]:
        count += 1
        cs = sizes[i]
        while i < len(sizes) and cs + 3 > sizes[i]:
            i += 1
print(count)


# task_06_05 - Создание архива

# Системный администратор вспомнил, что давно не делал архива пользовательских
# файлов. Однако, объем диска, куда он может поместить архив, может быть
# меньше, чем суммарный объем архивируемых файлов.
#
# Известно, какой объем занимают файлы каждого пользователя.
#
# Напишите программу, которая по заданной информации о пользователях и
# свободному объему на архивном диске определит максимальное число
# пользователей, чьи данные можно поместить в архив, при этом используя
# свободное место как можно более полно.
#
# Программа получает на вход в одной строке число S – размер свободного места
# на диске (натуральное, не превышает 10000), и число N – количество
# пользователей (натуральное, не превышает 100), после этого идет N чисел -
# объем данных каждого пользователя (натуральное, не превышает 1000),
# записанных каждое в отдельной строке.
#
# Выведите наибольшее количество пользователей, чьи данные могут быть помещены
# в архив.


S, N = list(map(int, input().split()))
v = [int(input()) for i in range(N)]
# for i in range(N):
#    v[i] = int(input())
v.sort()
i = 0
while i < len(v) and S >= v[i]:
    S -= v[i]
    i += 1
print(i)


# task_06_06 - Гражданская оборона

# Штаб гражданской обороны Тридесятой области решил обновить план спасения
# на случай ядерной атаки. Известно, что все n селений Тридесятой области
# находятся вдоль одной прямой дороги. Вдоль дороги также расположены
# m бомбоубежищ, в которых жители селений могут укрыться на случай
# ядерной атаки.
#
# Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
# необходимо для каждого селения определить ближайшее к нему бомбоубежище.
#
# В первой строке вводится число n - количество селений (1 <= n <= 100000).
# Вторая строка содержит n различных целых чисел, i-е из этих чисел задает
# расстояние от начала дороги до i-го селения. В третьей строке входных данных
# задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая
# строка содержит m различных целых чисел, i-е из этих чисел задает расстояние
# от начала дороги до i-го бомбоубежища. Все расстояния положительны и
# не превышают 10⁹. Селение и убежище могут располагаться в одной точке.
#
# Выведите n чисел - для каждого селения выведите номер ближайшего к нему
# бомбоубежища. Бомбоубежища пронумерованы от 1 до m в том порядке, в котором
# они заданы во входных данных.

# Указание
#
# Создайте список кортежей из пар (позиция селения, его номер в исходном
# списке), а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.
#
# Перебирайте селения в порядке возрастания.
#
# Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо
# выбрать ближайшее. При переходе к следующему селению не обязательно искать
# ближайшее бомбоубежище с самого начала. Его можно искать начиная с позиции,
# найденной для предыдущего города.
#
# Для хранения ответа используйте список, где индекс будет номером селения, а
# по этому индексу будет запоминаться номер бомбоубежища.

n = int(input())
distn = list(map(int, input().split()))
m = int(input())
distm = list(map(int, input().split()))

listn = [[distn[i], i] for i in range(len(distn))]
listm = [[distm[i], i] for i in range(len(distm))]
listn.sort()
listm.sort()

listnm = [0 for i in range(n)]
j = 0  # Перебираем убежища
for place in listn:  # Перебираем селения
    while j < len(listm) and place[0] > listm[j][0]:
        j += 1
    if j < len(listm) and abs(listm[j - 1][0] - place[0]) <= \
            abs(listm[j][0] - place[0]) or j >= len(listm):
        listnm[place[1]] = listm[j - 1][1]
    else:
        listnm[place[1]] = listm[j][1]
for i in range(len(listnm)):
    listnm[i] = listnm[i] + 1
print(*listnm)


# task_06_07 - Средний балл по классам

# В олимпиаде по информатике принимало участие несколько человек.
#
# Определите и выведите средние баллы участников олимпиады в 9 классе,
# в 10 классе, в 11 классе.
#
# Информация о результатах олимпиады записана в файле, каждая строка
# которого имеет вид:
# фамилия имя класс балл.
#
# Фамилия и имя — текстовые строки, не содержащие пробелов. Класс - одно из
# трех чисел 9, 10, 11. Балл - целое число от 0 до 100.
#
# В этой задаче файл необходимо считывать построчно, не сохраняя содержимое
# файла в памяти целиком.
#
# Выведите три числа: средние баллы по 9 классу, по 10 классу, по 11 классу.
# Входной файл в кодировке utf-8
# (используйте open('input.txt', 'r', encoding='utf-8')).


inFile = open('input_task_06_07.txt', 'r', encoding='utf8')
estimate = [[0, 0] for i in range(3)]
for line in inFile:
    lineData = line.strip().split()
    estimate[int(lineData[2]) - 9][0] += 1
    estimate[int(lineData[2]) - 9][1] += int(lineData[3])
inFile.close()
outFile = open('output_task_06_07.txt', 'w', encoding='utf8')
outFile.write(' '.join([str(estimate[i][1]/estimate[i][0]) for i in range(3)]))
outFile.close()



# task_06_08 - Отсортировать список участников по алфавиту

# Известно, что фамилии всех участников — различны. Сохраните
# в массивах список всех участников и выведите его, отсортировав по фамилии
# в лексикографическом порядке.
# При выводе указываете фамилию, имя участника и его балл.
#
# Используйте для ввода и вывода файлы input.txt и output.txt с указанием
# кодировки utf8.
# Например, для чтения откройте файл с помощью
# open('input.txt', 'r', encoding='utf8')

inFile = open('input_task_06_08.txt', 'r', encoding='utf8')
participantList = list()
i = 0
for line in inFile:
    lineData = line.strip().split()
    participantList.append(['', '', 0])
    participantList[i][0] = lineData[0]
    participantList[i][1] = lineData[1]
    participantList[i][2] = lineData[3]
    i += 1
inFile.close()
participantList.sort()
outFile = open('output_task_06_08.txt', 'w', encoding='utf8')
for part in participantList:
    print(' '.join(map(str, part)), file=outFile)
# outFile.write(' '.join([...) for i in range(3)]))
outFile.close()



# task_06_09 - Сортировка подсчетом

# Дан список из N (N≤2*10⁵) элементов, которые принимают целые значения
# от 0 до 100.
#
# Отсортируйте этот список в порядке неубывания элементов. Выведите
# полученный список.
#
# Решение оформите в виде функции CountSort(A), которая модифицирует
# передаваемый ей список.
# Использовать встроенные функции сортировки нельзя.


def CountSort(A):
    numCount = [0 for i in range(101)]
    numSort = list()
    for num in numList:
        numCount[num] += 1
    # return numCount
    for i in range(len(numCount)):
        # print((str(i) + ' ') * numCount[i])
        for count in range(numCount[i]):
            numSort.append(i)
    return numSort


numList = list(map(int, input().split()))
result = CountSort(numList)
print(' '.join(map(str, result)))



# task_06_10 - Клавиатура

# На региональном этапе Всероссийской олимпиады школьников по информатике
# в 2009 году предлагалась следующая задача.
#
# Всем известно, что со временем клавиатура изнашивается, и клавиши на ней
# начинают залипать. Конечно, некоторое время такую клавиатуру еще можно
# использовать, но для нажатий клавиш приходиться использовать большую силу.
#
# При изготовлении клавиатуры изначально для каждой клавиши задается
# количество нажатий, которое она должна выдерживать. Если знать эти величины
# для используемой клавиатуры, то для определенной последовательности нажатых
# клавиш можно определить, какие клавиши в процессе их использования
# сломаются, а какие — нет.
#
# Требуется написать программу, определяющую, какие клавиши сломаются
# в процессе заданного варианта эксплуатации клавиатуры.

# Первая строка входных данных содержит целое число n (1≤n≤1000) — количество
# клавиш на клавиатуре. Вторая строка содержит n целых чисел —с₁, с₂, … , сn,
# где сᵢ (1≤cᵢ≤100000) — количество нажатий, выдерживаемых i-ой клавишей.
# Третья строка содержит целое число k (1≤k≤100000) — общее количество нажатий
# клавиш, и последняя строка содержит k целых чисел pj (1≤pj≤n) —
# последовательность нажатых клавиш.
#
# Программа должна вывести n строк, содержащих информацию об исправности
# клавиш. Если i-я клавиша сломалась, то i-ая строка должна содержать слово
# YES, если же клавиша работоспособна — слово NO.

def countList(numList, n):
    numCount = [0 for i in range(n)]
    for num in numList:
        numCount[num-1] += 1
    return numCount

n = int(input())
cList = list(map(int, input().split()))
# print(cList)
k = int(input())
pList = list(map(int, input().split()))
# print(pList)
pSortList = countList(pList, len(cList))
# print(pSortList)
result = [cList[i] - pSortList[i] for i in range(len(cList))]
# print(result)
result = ["YES" * (result[i] < 0) + "NO" * (result[i] >= 0)
          for i in range(len(result))]
for res in result:
    print(res)


# task_06_11 - Максимальный балл по классам

# В олимпиаде по информатике принимало участие несколько человек. Победителем
# олимпиады становится человек, набравший больше всех баллов. Победители
# определяются независимо по каждому классу. Определите количество баллов,
# которое набрал победитель в каждом классе. Гарантируется, что в каждом
# классе был хотя бы один участник.

# Информация о результатах олимпиады записана в файле, каждая строка которого
# имеет вид: фамилия имя класс балл.
#
# Фамилия и имя — текстовые строки, не содержащие пробелов. Класс - одно
# из трех чисел 9, 10, 11. Балл - целое число от 0 до 100.
#
# В этой задаче файл необходимо считывать построчно, не сохраняя
# содержимое файла в памяти целиком.
#
# Выведите три числа: баллы победителя олимпиады по 9 классу, по 10 классу,
# по 11 классу. Входной файл в кодировке utf-8 (В Python используйте
# open('input.txt', 'r', encoding='utf-8')).

inFile = open('input_task_06_11.txt', 'r', encoding='utf-8')
data = list()
for line in inFile:
    d = tuple(line.strip().split())
    data.append((d[0], d[1], int(d[2]), int(d[3])))
inFile.close()
# print(data)
# sort_param_2_3 = lambda p: (p[2], -p[3])
# data.sort(key=sort_param_2_3)
# print(data)
maxEst = [0, 0, 0]
for d in data:
    if d[3] > maxEst[d[2]-9]:
        maxEst[d[2] - 9] = d[3]
with open('output_task_06_11.txt', 'w', encoding='utf-8') as outFile:
    outFile.write(' '.join(map(str, maxEst)))
# print(*maxEst, 'w', file="output_task_06_11.txt")


# task_06_12 - Результаты олимпиады

# В олимпиаде участвовало N человек. Каждый получил определенное количество
# баллов, при этом оказалось, что у всех участников разное число баллов.
# Упорядочите список участников олимпиады в порядке убывания набранных баллов.
#
# Программа получает на вход число участников олимпиады N. Далее идет N строк,
# в каждой строке записана фамилия участника, затем, через пробел, набранное
# им количество баллов.
#
# Выведите список участников (только фамилии) в порядке убывания набранных
# баллов.

def est(list):
    return -list[1]

N = int(input())
scores = list()
for i in range(N):
    d = tuple(input().split())
    scores.append((d[0], int(d[1])))
# print(scores)
# est = lambda list: -list[1]
scores.sort(key=est)
# print(scores)
# print(*[scores[i][0] for i in range(len(scores))])
for score in scores:
    print(score[0])


# task_06_13 - Количество победителей по классам

# В условиях предыдущей задачи определите количество школьников, ставших
# победителями в каждом классе. Победителями объявляются все, кто набрал
# наибольшее число баллов по данному классу. Гарантируется, что в каждом
# классе был хотя бы один участник.
#
# Выведите три числа: количество победителей олимпиады по 9 классу,
# по 10 классу, по 11 классу.

def est(list):
    return list[2], -list[3]

# scores = list()
# d = tuple(input().split())
# while d != ():
#     print(d)
#     scores.append((d[0], d[1], int(d[2]), int(d[3])))
#     d = tuple(input().split())
inFile = open('input_task_06_13.txt', 'r', encoding='utf-8')
# inFile = open('input.txt', 'r', encoding='utf-8')
scores = list()
for line in inFile:
    d = tuple(line.strip().split())
    scores.append((d[0], d[1], int(d[2]), int(d[3])))
inFile.close()
scores.sort(key=est)
# print(scores)
cl, count, maxScore = 0, 0, 0
outFile = open('output_task_06_13.txt', 'w', encoding='utf-8')
# outFile = open('output.txt', 'w', encoding='utf-8')
for sc in scores:
    if sc[2] != cl:
        if count != 0:
            print(count, end=' ')
            print(count, end=' ', file=outFile)
        cl = sc[2]
        maxScore = sc[3]
        count = 1
    elif maxScore == sc[3]:
        count += 1
print(count)
print(count, file=outFile)


# task_06_14 - Проходной балл

# Для поступления в вуз абитуриент должен предъявить результаты трех экзаменов
# в виде ЕГЭ, каждый из них оценивается целым числом от 0 до 100 баллов. При
# этом абитуриенты, набравшие менее 40 баллов (неудовлетворительную оценку)
# по любому экзамену из конкурса выбывают. Остальные абитуриенты участвуют
# в конкурсе по сумме баллов за три экзамена.
#
# В конкурсе участвует N человек, при этом количество мест равно K. Определите
# проходной балл, то есть такое количество баллов, что количество участников,
# набравших столько или больше баллов не превосходит K, а при добавлении к ним
# абитуриентов, набравших наибольшее количество баллов среди непринятых
# абитуриентов, общее число принятых абитуриентов станет больше K.

# Программа получает на вход количество мест K. Далее идут строки с
# информацией об абитуриентах, каждая из которых состоит из имени (текстовая
# строка содержащая произвольное число пробелов) и трех чисел от 0 до 100,
# разделенных пробелами.
#
# Используйте для ввода файл input.txt с указанием кодировки utf8.

# Программа должна вывести проходной балл в конкурсе. Выведенное значение
# должно быть минимальным баллом, который набрал абитуриент, прошедший по
# конкурсу.
#
# Также возможны две ситуации, когда проходной балл не определен.
#
# Если будут зачислены все абитуриенты, не имеющие неудовлетворительных
# оценок, программа должна вывести число 0.
#
# Если количество абитуриентов, имеющих равный максимальный балл больше чем K,
# программа должна вывести число 1.
#
# Используйте для вывода файл output.txt с указанием кодировки utf8.


inFile = open('input_task_06_14.txt', 'r', encoding='utf-8')
K = int(inFile.readline().strip())
data, est = list(), list()
for line in inFile:
    d = tuple(line.strip().split())
    # print(d)
    if int(d[-3]) >= 40 and int(d[-2]) >= 40 and int(d[-1]) >= 40:
        # data.append((d[:-3], int(d[-3]), int(d[-2]), int(d[-1]),
        # (int(d[-3]) + int(d[-2]) + int(d[-1]))))
        est.append(int(d[-3]) + int(d[-2]) + int(d[-1]))
inFile.close()
# data.sort(key=lambda tpl: -tpl[-1])
# print(data)
# est.sort(key=lambda p: -p)
est.sort(reverse=True)
# print(est)
count = len(est)
if count <= K:  # Нормально сдало экзамен не больше человек, чем имеется мест
    res = 0
elif K == 0:  # Количество мест равно нулю
    res = 1
elif est[K] == est[0]:  # K + 1 челове сдали на максимум
    res = 1
elif est[K] < est[K-1]:  # Следующий имеет меньший балл, все Ok
    res = est[K-1]
elif est[K] == est[K-1]:  # Следующий имеет такой же балл, нужно ограничивать
    i = 1
    while est[K] == est[K-i]:
        i += 1
    res = est[K-i]
# else:
#     print("Внимание! Пропустили!")
outFile = open('output_task_06_14.txt', 'w', encoding='utf-8')
outFile.write(str(res))
outFile.close()
# print(str(res))


# task_06_15 - Школы с наибольшим числом участников олимпиады

# В олимпиаде по информатике принимало участие N человек. Определите школы,
# из которых в олимпиаде принимало участие больше всего участников. В этой
# задаче необходимо считывать данные построчно, не сохраняя в памяти данные
# обо всех участниках, а только подсчитывая число участников для каждой школы.

# Информация о результатах олимпиады записана в файле, каждая из строк
# которого имеет вид: фамилия имя школа балл
#
# Фамилия и имя — текстовые строки, не содержащие пробелов. Школа — целое
# число от 1 до 99. Балл — целое число от 0 до 100.
#
# Выведите номера этих школ в порядке возрастания.

inFile = open('input_task_06_15.txt', 'r', encoding='utf-8')
schoolCount = [0 for i in range(100)]
for line in inFile:
    schoolCount[int(line.strip().split()[-2])] += 1
inFile.close()
maxCount = max(schoolCount)
maxSchool = [i for i in range(100) if schoolCount[i] == maxCount]
outFile = open('output_task_06_15.txt', 'w', encoding='utf-8')
print(*maxSchool)
print(*maxSchool, file=outFile)
outFile.close()


# task_06_16 - Максимальный балл не-победителя

# Зачет проводится отдельно в каждом классе. Победителями олимпиады становятся
# школьники, которые набрали наибольший балл среди всех участников в данном
# классе.
#
# Для каждого класса определите максимальный балл, который набрал школьник,
# не ставший победителем в данном классе.
#
# Выведите три целых числа.


inFile = open('input_task_06_16.txt', 'r', encoding='utf-8')
scores = list()
for line in inFile:
    d = tuple(line.strip().split())
    scores.append((int(d[-2]), int(d[-1])))
inFile.close()
scores.sort(key=lambda l: (l[0], -l[1]))
# print(scores)
cl, max, res = 8, 0, ''
for score in scores:
    if score[0] > cl:
        max = score[1]
        cl = score[0]
        flag = True
    elif flag and score[1] < max:
        print(score[1], end=' ')
        res += str(score[1]) + ' '
        flag = False
with open('output_task_06_16.txt', 'w', encoding='utf-8') as outFile:
    outFile.write(res)


# task_06_17 - Такси

# После затянувшегося совещания директор фирмы решил заказать такси, чтобы
# развезти сотрудников по домам. Он заказал N машин — ровно столько, сколько
# у него сотрудников. Однако когда они подъехали, оказалось, что у каждого
# водителя такси свой тариф за 1 километр.
#
# Директор знает, какому сотруднику сколько километров от работы до дома
# (к сожалению, все сотрудники живут в разных направлениях, поэтому нельзя
# отправить двух сотрудников на одной машине). Теперь директор хочет
# определить, сколько придется заплатить за перевозку всех сотрудников.
# Естественно, директор хочет заплатить как можно меньшую сумму.

# В первой строке записаны N чисел через пробел, задающих расстояния
# в километрах от работы до домов сотрудников компании. Во второй строке
# записаны N чисел — тарифы за проезд одного километра в такси.
#
# Выведите одно целое число — наименьшую сумму, которую придется заплатить
# за доставку всех сотрудников.


dist = list(map(int, input().split()))
tariff = list(map(int, input().split()))

dist.sort()
tariff.sort(reverse=True)

summ = 0
for i in range(len(dist)):
    summ += dist[i] * tariff[i]

print(summ)


# task_06_18 - Семипроцентный барьер

# В Государственную Думу Федерального Собрания Российской Федерации выборы
# производятся по партийным спискам. Каждый избиратель указывает одну партию,
# за которую он отдает свой голос. В Государственную Думу попадают партии,
# которые набрали не менее 7% от числа голосов избирателей.
#
# Дан список партий и список голосов избирателей. Выведите список партий,
# которые попадут в Государственную Думу.

# В первой строке входного файла написано слово PARTIES:. Далее идет список
# партий, участвующих в выборах.
#
# Затем идет строка, содержащая слово VOTES:. За ним идут названия партий,
# за которые проголосовали избиратели, по одному названию в строке. Названия
# могут быть только строками из первого списка.
#
# Программа должна вывести названия партий, получивших не менее 7% от числа
# голосов в том порядке, в котором они следуют в первом списке.

inFile = open('input_task_06_17.txt', 'r', encoding='utf-8')
parties, votes = list(), list()
for line in inFile:
    if line.strip() == "PARTIES:":
        f = False
    elif line.strip() == "VOTES:":
        f = True
    elif not f:
        parties.append(line.strip())
    elif f:
        votes.append(line.strip())
# print(parties)
# print(votes)
outFile = open('output_task_06_17.txt', 'w', encoding='utf-8')
for party in parties:
    if votes.count(party)/len(votes) >= 0.07:
        print(party)
        outFile.write(party + '\n')
outFile.close()


# task_06_19 - Упорядочить список партий по числу голосов

# Формат входных данных аналогичен предыдущей задаче. Выведите список всех
# партий, участвовавших в выборах, отсортировав его в порядке убывания
# количества голосов избирателей, а при равном количестве голосов - в
# лексикографическом порядке.


def srt(List):
    return -List[1], List[0]


inFile = open('input_task_06_19.txt', 'r', encoding='utf-8')
parties, votes = list(), list()
for line in inFile:
    if line.strip() == "PARTIES:":
        f = False
    elif line.strip() == "VOTES:":
        f = True
    elif not f:
        parties.append(line.strip())
    elif f:
        votes.append(line.strip())
# print(parties)
# print(votes)
p_v = [(parties[i], 0) for i in range(len(parties))]
for i in range(len(parties)):
    p_v[i] = (parties[i], votes.count(parties[i]))
# print(p_v)
p_v.sort(key=srt)
# print(p_v)
outFile = open('output_task_06_19.txt', 'w', encoding='utf-8')
for pv in p_v:
    print(pv[0])
    outFile.write(pv[0] + '\n')
outFile.close()
