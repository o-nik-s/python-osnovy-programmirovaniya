# Словари

# Словарь - это  сопоставление любого объекта любому другому объекту.

# В отличие от словарей бумажных, где все упорядочено, словари в Python не упорядочены:
# то есть вы просто берете ключ — получаете значение.

capitals = {'Russia': 'Moscow', 'France': 'Paris'}
print(capitals)
print(capitals['Russia'])

# В качестве ключа должен быть не изменяемый объект /строка, число, frozenset/, потому как от него считается хэш

# print(capitals['USA'])
# То есть при попытке обратиться к ключу, которого нет, через квадратные скобки у нас возникает ошибка, и все ломается.

# Добавим США
capitals['USA'] = 'Washington'
print(capitals['USA'])
print(capitals)
print(*capitals) # Напечатались ключи словаря

# Удаление элементов
del capitals['France']
print(capitals)

# Проверим наличие ключа
print('Russia' in capitals)
# Например, мы можем напечатать результат проверки, есть ли у нас ключ в множестве в словаре.
# На самом деле, в множестве, я не просто так оговорился, потому что делается это абсолютно точно так же,
# как для множества, то есть in. И, в общем-то, суть словаря — это абсолютно то же самое, что и множество.
# То есть у нас в словаре читается хеш от ключа, и ему просто сопоставляется какое-то дополнительное значение,
# хеш от которого никак не считается.

# Например, по столице с помощью такого словаря мы никак государство узнать не можем. То есть по значению ключ
# определить очень сложно. В общем-то, нам придется перебрать все пары ключ — значение и для каждого отдельно
# проверить. По сути, сделать линейный поиск.


# Как конструировать словарь от каких-то других объектов?

myDict = dict()  # Создали словарь
# Превращает параметр в словарь; нужно передавать пары объектов /например, в виде кортежа/
myDict = dict([('x', 5), ('y', 3)]) # То есть словарь конструируется из какого-то итерируемого объекта,
# который умеет возвращать кортежи из двух элементов: ключ и значение
print(myDict)

# Чаще сначала создается пустой словарь, потом по одному туда добавляются элементы

# Как перебрать все элементы словаря.
for i in myDict:
    print(i)
# Перебираются ключи; в случайном порядке, поскольку считается хэш-функция от них

for i in myDict:
    print(i, myDict[i])
# Вывели содержимое



'''В жизни нередко возникает необходимость сопоставить ключу значение. Например, в англо-русском словаре 
английскому слову сопостовляется одно или несколько русских слов. Здесь английское слово является ключам, 
а русское - значением.

В языке Питон есть структура данных словарь, которая позволяет реализовывать подобные операции. При этом 
объекты-ключи уникальны и каждому из них сопоставлен некоторый объект-значение. Ограничения на ключи такие же, 
как на элементы множества, а вот значения могут быть и изменяемыми.

По-сути, словарь является множеством, где каждому элементу-ключу сопоставлен еще и объект-значение.

Создать словарь в исходном тексте программы можно записав в фигурных скобках пары ключ-значения через запятую, 
а внутри пары ключ отделяется от значения двоеточием:'''

countries = {'Russia' : 'Europe', 'Germany' : 'Europe', 'Australia' : 'Australia'}

'''Добавлять пары ключ значение в словарь очень просто: это делается по аналогии со списками:'''
sqrs = {}
sqrs[1] = 1
sqrs[2] = 4
sqrs[10] = 100
print(sqrs)

'''Пустой словарь можно создать, написав пустые фигурные скобки (это будет словарь, а не множество).

Словарь также можно конструировать из других объектов с помощью функции dict:'''
myDict = dict([['key1', 'value1'], ('key2', 'value2')])
print(myDict)
'''На вход функции должен подавать iterable, каждый элемент которого, в свою очередь, является iterable 
строго с двумя элементами - ключом и значением.'''

'''Узнавать значение по ключу можно также с помощью записи ключа после имени словаря в квадратных скобках:'''
phones = {'police' : 102, 'ambulance' : 103, 'firefighters' : 101}
print(phones['police'])
'''Если такого ключа в словаре нет, то возникнет ошибка.'''

'''Удаление элемента из словаря делается специальной командой del. Это не функция, после слова del 
ставится пробел, затем пишется имя словаря, а затем, в квадратных скобках, удаляемый ключ:'''
phones = {'police' : 102, 'ambulance' : 103, 'firefighters' : 101}
del phones['police']
print(phones)

'''Проверка принадлежности ключа словарю осуществляется с помощью операции key in dictionary (точно также, 
как проверка принадлежности элемента множеству).'''

'''Словарь является iterable и возвращает ключи в случайном порядке. Например, такой код напечатает 
содержимое словаря:'''
phones = {'police' : 102, 'ambulance' : 103, 'firefighters' : 101}
for service in phones:
    print(service, phones[service])

'''Также существует метод items, который возвращает iterable, содержащий в себе кортежи ключ-значение для всевозможных ключей.'''
phones = {'police' : 102, 'ambulance' : 103, 'firefighters' : 101}
for service, phone in phones.items():
    print(service, phone)



# Когда нужно использовать словари

# 1. Использовать словарь по прямому назначению.

# 2. Подсчет числа объектов, то есть сколько раз у вас какой объект встретился.
# Посчитаем количество вхождений каждой буквы в нашу строку.
s = input()
letters = dict()
for c in s:
    if c in letters:
        letters[c] += 1
    else:
        letters[c] = 1
for c in letters:
    print(c, letters[c])
print()
# Часть результат нужно упорядочить
for c in sorted(letters): # Мы идем по отсортированным ключам и берем из словаря значения, им соответствующие
    print(c, letters[c]) # Вывелось в алфавитном порядке
print()


# Упрощение программы
letters = dict() # Очищаем результат для дальнейшего исподьзования переменной
for c in s:
    if c not in letters:
        letters[c] = 0
    letters[c] += 1
for c in sorted(letters):
    print(c, letters[c])
print()


# Поскольку такая задача возникает довольно часто, то в словаре предусмотрен метод get() с двумя параметрами
letters = dict() # Очищаем результат для дальнейшего исподьзования переменной
for c in s:
    letters[c] = letters.get(c, 0) + 1
for c in sorted(letters):
    print(c, letters[c])
print()

# Метод get() принимает два параметра:
# Ключ, для которого нужно вернуть значение
# И значение, которое нужно вернуть, если такого ключа не нашлось

# Т.е .мы узнаем, сколько раз встречалась такая буква
# И если ее вообще не было, получаем ноль
# И ко всему этому прибавляем 1


# Различные методы словаря: copy, clear, fromkeys, get, items — в общем, достаточно много методов.
# Все из них полезны в каких-то разных ситуациях.


# 3. Для хранения разреженных массивов
# Задача о подсчете минимальной цены бензина.
# Есть заправки, где продается 92-й, 95-й и 98-й бензины. На каждом известна цена и нужно сказать
# минимальную цену для каждого типа бензина.
gasCost = {}
n = int(input())
a92, a95, a98 = map(int, input().split())
gasCost[92] = a92
gasCost[95] = a95
gasCost[98] = a98
for i in range(n - 1):
    a92, a95, a98 = map(int, input().split())
    gasCost[92] = min(a92, gasCost(92))
    gasCost[95] = min(a95, gasCost(95))
    gasCost[98] = min(a98, gasCost(98))
print(gasCost[92], gasCost[95], gasCost[98])


'''По прямому назначению: сопоставление ключа значению (названия дней недели, переводы слов и т.д.).

Для подсчета числа объектов. При очередной встрече объекта счетчик увеличивается на единицу. Это похоже на сортировку 
подсчётом.

Для хранения разреженных массивов. Например, если мы хотим хранить цену 92, 95 и 98 бензина, то могли бы 
создать массив из 99 элементов и хранить в нём. Но большая часть элементов не нужны - массив разреженный. 
Словарь здесь подходит больше.

Для подсчета числа элементов удобно использовать метод get. Он принимает два параметра: ключ для которого нужно 
вернуть значения и значение, которое будет возвращено, если такого ключа нет. Например, подсчитать сколько раз 
входит в последовательность каждое из чисел можно с помощью такого кода:'''

seq = map(int, input().split())
countDict = {}
for elem in seq:
    countDict[elem] = countDict.get(elem, 0) + 1
for key in sorted(countDict):
    print(key, countDict[key], sep = ' : ')


# Хотим оптимизировать код, используя преимущество словарей, а не три переменных, как это сделано сейчас
gasCost = {}
n = int(input())
costs = list(map(int, input().split()))
btypes = (92, 95, 98)
for now in range(len(btypes)):
    gasCost[btypes[now]] = costs[now]
for i in range(n - 1):
    costs = list(map(int, input().split()))
    for now in range(len(btypes)):
        gasCost[btypes[now]] = min(costs[now], gasCost[btypes[now]])
print(gasCost[92], gasCost[95], gasCost[98])
# Такой код намного универсальнее. И подойдет и для большего количества типов бензина

# Так словари позволяют хранить разрешенные массивы



# Полезные методы строк

s = input()
print(s.isalpha()) # Является ли строка буквенной строкой /состоит ли строка только из букв/
print(s.isalnum()) # Буквы и цифры
print(s.isdigit()) # Только цифры
print(s.islower()) # Только маленькие буквы
print(s.isupper()) # Только большие буквы
print(s.strip())   # Обрезать с обеих сторон
print(s.lstrip())  # Обрезать только слева
print(s.rstrip())  # Обрезать только справа


# У нас есть англо-латинский словарь, где английскому слову сопоставляется его латинский перевод
# Нужно по нему сделать латино-английский словарь

fin = open('input_lesson_07_02.txt')
myDict = {}
for line in fin:
    eng, latins = line.split('-')
    latinsList = latins.split(',')
    eng = eng.strip()
    for latin in latinsList:
        if latin.strip() not in myDict:
            myDict[latin.strip()] = []
        myDict[latin.strip()].append(eng)
print(myDict)
pass


'''
It's dangerous to go alone! Take this:
isalpha - проверяет, что все символы строки являются буквами.
isdigit - проверяет, что все символы строки являются цифрами.
isalnum - проверяет, что все символы строки являются буквами или цифрами.
islower - проверяет, что все символы строки являеются маленькими (строчными) буквами.
isupper - проверяет, что все символы строки являеются большими (заглавными, прописными) буквами.
lstrip - обрезает все пробельные символы в начале строки.
rstrip - обрезает все пробельные символы в конце строки.
strip - обрезает все пробельные символы в начале и конце строки.'''


# Пример решения сложной задачи на словари

# Сделаем все красиво

# Должны отсортировать все ключи по алфавиту

fin = open('input_lesson_07_02.txt')
myDict = {}
for line in fin:
    eng, latins = line.split('-')
    latinsList = latins.split(',')
    eng = eng.strip()
    for latin in latinsList:
        if latin.strip() not in myDict:
            myDict[latin.strip()] = []
        myDict[latin.strip()].append(eng)
for latin in sorted(myDict):
    # Для каждого латинского слова мы должны вывести все его переводы на английский язык через запятую
    # print(latin, '-', ', '.join(myDict[latin]))
    # Порядка никакого нет, как задавались, так и выдаются
    # Для выходных данных в неправильном порядке получаем неправильный порядок
    # Поэтому
    print(latin, '-', ', '.join(sorted(myDict[latin])))
pass


# Хранение генеалогического древа

tree = {'a':
            {'b': dict(), # Бездетный
            'c': {
                'd': dict(),
                'e': dict()
                }
             }
        }
# Словари можно задавать в нескольких строчках

# Обращаться к элементам словаря достаточно хитро,
# Но можно написать рекурсивную функцию, которая принимает на вход очередной словарь,
# перебирает все ключи этого словаря /это дети/, для каждого ребенка что-то делает
# /например, печатает полную историю/.

# Таким образом, словари можно использовать для хранения любых деревьев
# Например, бинарных. Хотя в этом случае лучше воспользоваться списками.



'''Идея решения заключается в следующем: разрежем каждую строку на английское и латинские слова. 
Каждое из латинских слов возьмем в качестве ключа и добавим к его значениям английское слово 
(переводов может быть несколько). Затем пройдем по сортированным ключам и для каждого ключа 
выведем отсортированный список переводов:'''

n = int(input())
latinEnglish = {}
for i in range(n):
    line = input()
    english = line[:line.find('-')].strip()
    latinsStr = line[line.find('-') + 1:].strip()
    latins = map(lambda s : s.strip(), latinsStr.split(','))
    for latin in latins:
        if latin not in latinEnglish:
            latinEnglish[latin] = []
        latinEnglish[latin].append(english)
print(len(latinEnglish))
for latin in sorted(latinEnglish):
    print(latin, '-', ', '.join(sorted(latinEnglish[latin])))

