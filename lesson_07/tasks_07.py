# task_07_01 - Количество различных чисел

# Дан список чисел, который может содержать до 100000 чисел. Определите,
# сколько в нем встречается различных чисел.
#
# Вводится список целых чисел. Все числа списка находятся на одной строке.
# Выведите ответ на задачу.

numList = list(map(int, input().split()))
numSet = set(numList)
print(len(numSet))



# task_07_02 - Количество совпадающих

# Даны два списка чисел, которые могут содержать до 100000 чисел каждый.
# Посчитайте, сколько чисел содержится одновременно как в первом списке,
# так и во втором.
#
# Примечание. Эту задачу на Питоне можно решить в одну строчку.
#
#
# Вводятся два списка чисел. Все числа каждого списка находятся на отдельной
# строке.
# Выведите ответ на задачу.

print(len(set(list(map(int, input().split()))) &
          set(list(map(int, input().split())))))



# task_07_03 - Пересечение множеств

# Даны два списка чисел, которые могут содержать до 10000 чисел каждый.
# Выведите все числа, которые входят как в первый, так и во второй список
# в порядке возрастания.
#
# Примечание. И даже эту задачу на Питоне можно решить в одну строчку.
#
#
# Вводятся два списка целых чисел. Все числа каждого списка находятся
# на отдельной строке.
#
# Выведите ответ на задачу.
#
# Примечания. Ввод и вывод осуществлять с помощью файлов.


with open('input_task_07_03.txt', "r", encoding='utf-8') as inFile:
    res = sorted(set(map(int, inFile.readline().strip().split())) &
                 set(map(int, inFile.readline().strip().split())))
with open('output_task_07_03.txt', "w", encoding='utf-8') as outFile:
    print(*res, file=outFile)



# task_07_04 - Встречалось ли число раньше

# Во входной строке записана последовательность чисел через пробел.
# Для каждого числа выведите слово YES (в отдельной строке), если это число
# ранее встречалось в последовательности или NO, если не встречалось.
#
# Вводится список чисел. Все числа списка находятся на одной строке.
#
# Выведите ответ на задачу.


numList = list(map(int, input().split()))
numSet = set()
for num in numList:
    if num in numSet:
        print("YES")
    else:
        print("NO")
        numSet.add(num)



# task_07_05 - Кубики

# Аня и Боря любят играть в разноцветные кубики, причем у каждого из них
# свой набор и в каждом наборе все кубики различны по цвету. Однажды дети
# заинтересовались, сколько существуют цветов таких, что кубики каждого цвета
# присутствуют в обоих наборах. Для этого они занумеровали все цвета
# случайными числами. На этом их энтузиазм иссяк, поэтому вам предлагается
# помочь им в оставшейся части. Номер любого цвета — это целое число
# в пределах от 0 до 10⁹.

# В первой строке входного файла записаны числа N и M — количество кубиков
# у Ани и Бори соответственно. В следующих N строках заданы номера цветов
# кубиков Ани. В последних M строках номера цветов кубиков Бори.
#
# Выведите сначала количество, а затем отсортированные по возрастанию номера
# цветов таких, что кубики каждого цвета есть в обоих наборах, затем
# количество и отсортированные по возрастанию номера остальных цветов у Ани,
# потом количество и отсортированные по возрастанию номера остальных цветов
# у Бори.


N, M = tuple(map(int, input().split()))
NSet, MSet = set(), set()
NSet = {int(input()) for i in range(N)}
MSet = {int(input()) for i in range(M)}
NMSet = NSet & MSet
print(len(NMSet))
print(*sorted(NMSet))
NSetMinusNMSet = NSet - NMSet
print(len(NSetMinusNMSet))
print(*sorted(NSetMinusNMSet))
MSetMinusNMSet = MSet - NMSet
print(len(MSetMinusNMSet))
print(*sorted(MSetMinusNMSet))



# task_07_06 - Количество слов в тексте

# Во входном файле (вы можете читать данные из sys.stdin, подключив библиотеку
# sys) записан текст. Словом считается последовательность непробельных
# символов идущих подряд, слова разделены одним или большим числом пробелов
# или символами конца строки. Определите, сколько различных слов содержится
# в этом тексте.

# Если ввод-вывод осуществляется со стандартного ввода, то иногда бывает
# удобно работать со стандартным вводом, как с файлом. Для этого необходимо
# подключить модуль sys, и использовать объект ( sys.stdin ), определенный
# в этом модуле, который связан со стандартным вводом. Для того, чтобы
# завершить ввод (послать программе сигнал оконце файла при чтении из
# стандартного ввода) нужно нажать >>> Ctrl+D (Windows) !!!


import sys

words = set()
for line in sys.stdin.readlines():
    # с помощью(readlines()) считываем ВСЕ строки
    for word in line.split():
        words.add(str(word))
# print(words)
print(len(words))



# task_07_07 - Угадай число

# Август и Беатриса играют в игру. Август загадал натуральное число от 1 до n.
# Беатриса пытается угадать это число, для этого она называет некоторые
# множества натуральных чисел. Август отвечает Беатрисе YES, если среди
# названных ей чисел есть задуманное или NO в противном случае. После
# нескольких заданных вопросов Беатриса запуталась в том, какие вопросы
# она задавала и какие ответы получила и просит вас помочь ей определить,
# какие числа мог задумать Август.

# Первая строка входных данных содержит число n — наибольшее число, которое
# мог загадать Август. Далее идут строки, содержащие вопросы Беатрисы. Каждая
# строка представляет собой набор чисел, разделенных пробелами. После каждой
# строки с вопросом идет ответ Августа: YES или NO. Наконец, последняя строка
# входных данных содержит одно слово HELP.
#
# Вы должны вывести (через пробел, в порядке возрастания) все числа, которые
# мог задумать Август.


n = int(input())
numSet = set(range(1, n+1))
line = input()
while line != 'HELP':
    line = line.split()
    answer = input()
    if answer == "YES":
        numSet &= set(map(int, line))
    elif answer == "NO":
        numSet -= set(map(int, line))
    line = input()
print(*sorted(numSet))



# task_07_08 - Угадай число - 2

# Август и Беатриса продолжают играть в игру, но Август начал жульничать.
# На каждый из вопросов Беатрисы он выбирает такой вариант ответа YES или NO,
# чтобы множество возможных задуманных чисел оставалось как можно больше.
# Например, если Август задумал число от 1 до 5, а Беатриса спросила про числа
# 1 и 2, то Август ответит NO, а если Беатриса спросит про 1, 2, 3, то Август
# ответит YES. Если же Бетриса в своем вопросе перечисляет ровно половину из
# задуманных чисел, то Август из вредности всегда отвечает NO. Наконец, Август
# при ответе учитывает все предыдущие вопросы Беатрисы и свои ответы на них,
# то есть множество возможных задуманных чисел уменьшается.
#
# Вам дана последовательность вопросов Беатрисы. Приведите ответы Августа
# на них. Первая строка входных данных содержит число n — наибольшее число,
# которое мог загадать Август. Далее идут строки, содержащие вопросы Беатрисы.
# Каждая строка представляет собой набор чисел, разделенных пробелами.
# Последняя строка входных данных содержит одно слово HELP.

# Для каждого вопроса Беатрисы выведите ответ Августа на этот вопрос. После
# этого выведите (через пробел, в порядке возрастания) все числа, которые мог
# загадать Август после ответа на все вопросы Беатрисы.


n = int(input())
numSet = set(range(1, n+1))
line = input()
while line != 'HELP':
    line = line.split()
    quest = set(map(int, line))
    multSet = numSet & set(map(int, line))
    if len(multSet) <= len(numSet) - len(multSet):
        print("NO")
        numSet -= multSet
    else:
        print("YES")
        numSet = multSet
    line = input()
print(*sorted(numSet))



# task_07_09 - Полиглоты

# Каждый из N школьников некоторой школы знает Mᵢ языков. Определите, какие
# языки знают все школьники, и языки, которые знает хотя бы один из школьников.

# Первая строка входных данных содержит количество школьников N. Далее идет N
# чисел Mᵢ, после каждого из чисел идет Mᵢ строк, содержащих названия языков,
# которые знает i-й школьник. Длина названий языков не превышает 1000
# символов, количество различных языков не более 1000. 1≤N≤1000, 1≤Mᵢ≤500.
#
# В первой строке выведите количество языков, которые знают все школьники.
# Начиная со второй строки - список таких языков. Затем - количество языков,
# которые знает хотя бы один школьник, на следующих строках - список таких
# языков.


N = int(input())
langs, langAll = set(), set()
for i in range(N):
    M = int(input())
    thisLangs = set()
    for j in range(M):
        lang = input()
        thisLangs.add(lang)
    if i == 0:
        langAll |= thisLangs
    else:
        langAll &= thisLangs
    langs |= thisLangs
print(len(langAll))
for lang in langAll:
    print(lang)
print(len(langs))
for lang in langs:
    print(lang)



# task_07_10 - Пересадки

# На Новом проспекте для разгрузки было решено пустить два новых автобусных
# маршрута на разных участках проспекта. Известны конечные остановки каждого
# из автобусов. Определите количество остановок, на которых можно пересесть
# с одного автобуса на другой.

# Вводятся четыре числа, не превосходящие 100, задающие номера конечных
# остановок. Сначала для первого, потом второго автобуса (см. примеры
# и рисунок).
#
# Ваша программа должна выводить одно число – искомое количество остановок.
#
# Примечания
# Пояснения. Первый пример (см. рисунок): первый автобус ходит с 3-й остановки
# по 6-ю и обратно, а второй с 2-й по 4-ю и обратно. Пересесть с одного
# автобуса на другой можно на 3-й и 4-й остановках. Их две. Второй пример:
# автобусы не имеют общих остановок.


l1, r1, l2, r2 = tuple(map(int, input().split()))
set1 = set(range(min(l1, r1), max(l1, r1) + 1))
set2 = set(range(min(l2, r2), max(l2, r2) + 1))
print(len(set1 & set2))



# task_07_11 - Забастовки

# Политическая жизнь одной страны очень оживленная. В стране действует
# K политических партий, каждая из которых регулярно объявляет национальную
# забастовку. Дни, когда хотя бы одна из партий объявляет забастовку,
# при условии, что это не суббота или воскресенье (когда и так никто
# не работает), наносят большой ущерб экономике страны. i-я партия объявляет
# забастовки строго каждые bᵢ дней, начиная с дня с номером aᵢ. То есть i-я
# партия объявляет забастовки в дни aᵢ, aᵢ+bᵢ, aᵢ+2bᵢ и т.д. Если в какой-то
# день несколько партий объявляет забастовку, то это считается одной
# общенациональной забастовкой. В календаре страны N дней, пронумерованных
# от 1 до N. Первый день года является понедельником, шестой и седьмой дни
# года — выходные, неделя состоит из семи дней.

# Программа получает на вход число дней в году N (1≤N≤10⁶) и число
# политических партий K (1≤K≤100). Далее идет K строк, описывающие графики
# проведения забастовок. i-я строка содержит числа aᵢ и bᵢ (1≤aᵢ,bᵢ≤N).
#
# Выведите единственное число: количество забастовок, произошедших в течение
# года.
#
# Примечания
# Первая партия объявляет забастовки в дни 2, 5, 8, 11, 14, 17. Вторая партия
# объявляет забастовки в дни 3, 8, 13, 18. Третья партия —в дни 9 и 17. Дни
# номер 6, 7, 13, 14 являются выходными. Таким образом,общенациональные
# забастовки пройдут в дни 2, 3, 5, 8, 9, 11, 17, 18.


N, K = tuple(map(int, input().split()))
strikeDays = set()
for i in range(K):
    a, b = tuple(map(int, input().split()))
    thisStrikeDays = set(range(a, N+1, b))
    strikeDays |= thisStrikeDays
holidays = set(range(6, N+1, 7)) | set(range(7, N+1, 7))
strikeDays -= holidays
# print(strikeDays)
print(len(strikeDays))


# task_07_12 - Телефонные номера

# Телефонные номера в адресной книге мобильного телефона имеют один
# из следующих форматов: +7<код><номер>, 8<код><номер><номер>, где <номер> —
# это семь цифр, а <код> — это три цифры или три цифры в круглых скобках.
# Если код не указан, то считается, что он равен 495. Кроме того, в записи
# телефонного номера может стоять знак “-” между любыми двумя цифрами
# (см. пример). На данный момент в адресной книге телефона Васи записано
# всего три телефонных номера, и он хочет записать туда еще один. Но он
# не может понять, не записан ли уже такой номер в телефонной книге.
# Помогите ему! Два телефонных номера совпадают, если у них равны коды
# и равны номера. Например, +7(916)0123456 и 89160123456 — это один и тот же
# номер.

# В первой строке входных данных записан номер телефона, который Вася хочет
# добавить в адресную книгу своего телефона. В следующих трех строках записаны
# три номера телефонов, которые уже находятся в адресной книге телефона Васи.
# Гарантируется, что каждая из записей соответствует одному из трех
# приведенных в условии форматов.

# Для каждого телефонного номера в адресной книге выведите YES (заглавными
# буквами), если он совпадает с тем телефонным номером,который Вася хочет
# добавить в адресную книгу или NO (заглавными буквами) в противном случае.


def numberTranslate(number):
    plus = False
    numberNow = ""
    for num in number:
        if num == "+":
            plus = True
        elif num.isdigit():
            if plus and int(num) == 7:
                num = "8"
                plus = False
            numberNow += num
    if len(numberNow) < 11:
        numberNow = "8495" + numberNow
    return numberNow


number = numberTranslate(input())
for i in range(3):
    if number == numberTranslate(input()):
        print("YES")
    else:
        print("NO")


# task_07_13 - Страны и города

# Дан список стран и городов каждой страны. Затем даны названия городов.
# Для каждого города укажите, в какой стране он находится.

# Программа получает на вход количество стран N. Далее идет N строк, каждая
# строка начинается с названия страны, затем идут названия городов этой страны.
# Название каждого город состоит из одного слова. В следующей строке записано
# число M, далее идут M запросов — названия каких-то M городов, перечисленных
# выше.
#
# Для каждого из запроса выведите название страны, в котором находится данный
# город.

N = int(input())
countryData = list(list() for i in range(N))
cityData = dict()
for i in range(N):
    countryData[i] = input().split()
for country in countryData:
    for i in range(len(country)):
        if i != 0:
            cityData[country[i]] = country[0]
M = int(input())
for i in range(M):
    print(cityData[input()])


# task_07_14 - Номер появления слова

# Во входном файле (вы можете читать данные из файла input.txt) записан текст.
# Словом считается последовательность непробельных подряд идущих символов.
# Слова разделены одним или большим числом пробелов или символами конца строки.
# Для каждого слова из этого текста подсчитайте, сколько раз оно встречалось
# в этом тексте ранее.


inFile = open("input_task_07_14.txt")
wordsDict = dict()
for line in inFile.readlines():
    wordsLine = line.split()
    for word in wordsLine:
        count = wordsDict.get(word, 0)
        print(count, end=' ')
        wordsDict[word] = count + 1
inFile.close()


# task_07_15 - Словарь синонимов

# Вам дан словарь, состоящий из пар слов. Каждое слово является синонимом
# к парному ему слову. Все слова в словаре различны. Для одного данного слова
# определите его синоним.

# Программа получает на вход количество пар синонимов N. Далее следует
# N строк, каждая строка содержит ровно два слова-синонима. После этого
# следует одно слово.
#
# Программа должна вывести синоним к данному слову.
#
# Примечания
# Эту задачу можно решить и без словарей (сохранив все входные данные
# в списке), но решение со словарем будет более простым.

N = int(input())
wordsDict = dict()
for i in range(N):
    inputWords = input().split()
    wordsDict[inputWords[0]] = inputWords[1]
    wordsDict[inputWords[1]] = inputWords[0]
print(wordsDict[input()])


# task_07_16 - Выборы в США

# Как известно, в США президент выбирается не прямым голосованием, а путем
# двухуровневого голосования. Сначала проводятся выборы в каждом штате и
# определяется победитель выборов в данном штате. Затем проводятся
# государственные выборы: на этих выборах каждый штат имеет определенное число
# голосов — число выборщиков от этого штата. На практике, все выборщики
# от штата голосуют в соответствии с результатами голосования внутри штата, то
# есть на заключительной стадии выборов в голосовании участвуют штаты, имеющие
# различное число голосов. Вам известно за кого проголосовал каждый штат и
# сколько голосов было отдано данным штатом. Подведите итоги выборов: для
# каждого из участника голосования определите число отданных за него голосов.

# Каждая строка входного файла содержит фамилию кандидата, за которого отдают
# голоса выборщики этого штата, затем через пробел идет количество выборщиков,
# отдавших голоса за этого кандидата.
#
# Выведите фамилии всех кандидатов в лексикографическом порядке, затем, через
# пробел, количество отданных за них голосов.


candDict = dict()
with open("input_task_07_16.txt") as inFile:
    for line in inFile:
        candInfo = line.split()
        candDict[candInfo[0]] = candDict.get(candInfo[0], 0) + int(candInfo[1])
with open("output_task_07_16.txt", "w") as outFile:
    for key in sorted(candDict):
        outFile.write(key + ' ' + str(candDict[key]) + '\n')


# task_07_17 - Самое частое слово

# Дан текст. Выведите слово, которое в этом тексте встречается чаще всего.
# Если таких слов несколько, выведите то, которое меньше в лексикографическом
# порядке.


txt = ""
wordDict = dict()
wordList = list()
with open("input_task_07_17.txt") as inFile:
    for line in inFile:
        txt += line  # .strip() + ' '
for word in txt.split():
    wordDict[word] = wordDict.get(word, 0) + 1
for word in wordDict:
    wordList.append([word, wordDict[word]])
wordList = sorted(wordList, key=lambda p: (-p[1], p[0]))
print(wordList[0][0])


# task_07_18 - Частотный анализ

# Дан текст. Выведите все слова, встречающиеся в тексте, по одному на каждую
# строку. Слова должны быть отсортированы по убыванию их количества появления
# в тексте, а при одинаковой частоте появления — в лексикографическом порядке.

# Указание.
# После того, как вы создадите словарь всех слов, вам захочется отсортировать
# его по частоте встречаемости слова. Желаемого можно добиться, если создать
# список, элементами которого будут кортежи из двух элементов: частота
# встречаемости словаи само слово. Например,
# [(2, 'hi'), (1, 'what'), (3, 'is')].
# Тогда стандартная сортировка будет сортировать список кортежей, при этом
# кортежи сравниваются по первому элементу, а если они равны — то по второму.
# Это почти то, что требуется в задаче.


txt = ""
wordDict = dict()
wordList = list()
with open("input_task_07_18.txt") as inFile:
    for line in inFile:
        for word in line.split():  # .strip() + ' '
            wordDict[word] = wordDict.get(word, 0) + 1
for word in wordDict:
    wordList.append([word, wordDict[word]])
wordList = sorted(wordList, key=lambda p: (-p[1], p[0]))
for word in wordList:
    print(word[0])


# task_07_19 - Выборы Президента

# В выборах Президента Российской Федерации побеждает кандидат, набравший
# свыше половины числа голосов избирателей. Если такого кандидата нет, то во
# второй тур выборов выходят два кандидата, набравших наибольшее число голосов.

# Каждая строка входного файла содержит имя кандидата, за которого отдал голос
# один избиратель. Известно, что общее число кандидатов не превосходит 20, но
# в отличии от предыдущих задач список кандидатов явно не задан. Читайте
# данные из файла input.txt с указанием кодировки utf8.
#
# Если есть кандидат, набравший более 50% голосов, программа должна вывести
# его имя. Если такого кандидата нет, программа должна вывести имя кандидата,
# занявшего первое место, затем имя кандидата, занявшего второе место.
# Выводите данные в файл output.txt с указанием кодировки utf8.


import io

candDict = dict()
candList = list()
voices = 0
inFile = io.open("input_task_07_19.txt", "r", encoding='utf-8')
for line in inFile:
    cand = line.strip()
    candDict[cand] = candDict.get(cand, 0) + 1
    voices += 1
inFile.close()
for cand in candDict:
    candList.append((cand, candDict[cand]))
candList.sort(key=lambda p: (-p[1], p[0]))
outFile = io.open("output_task_07_19.txt", "w", encoding='utf-8')
outFile.write(candList[0][0] + '\n')
if candList[0][1] / voices <= 0.5:
    outFile.write(candList[1][0])
outFile.close()
