# Итераторы и генераторы

s = 0
for i in range(1000000):
    s += 1
print(s)

# Если бы мы хранили весь список в памяти, то потратили бы очень много памяти?
# Зачем нам знать эти числа, если мы знаем правила, по которым получается следующее число.

# Что нам нужно для правила? Какое это правило? Нам нужно начальное значение, откуда мы
# начинаем считать. В range это — 0. Нам нужен переход, по умолчанию это 1. И нам нужно,
# наконец, максимальное значение, до какого момента мы считаем. Это, собственно, параметр
# range с одним параметром.

# Как же они, такие правила записываются? Ну, в Python почти все, что есть стандартное,
# можно написать на Python. Давайте напишем свой range, который будет делать приdмерно
# то же самое: не хранить в себе всю последовательность, а только описывать правила ее генерации.

def myRange(n):
    i = 0
    while i < n:
        yield i
        i += 1

s = 0
for i in myRange(1000000):
    s += 1
print(s)

# yield - Это приостановка работы функции с возвращением результата.
# Если return, который мы привыкли, функции возвращает результат и оканчивает работу функции,
# то yield возвращает результат, но запоминает состояние функции, то есть все локальные переменные,
# которые в ней были, то место, в которое нужно вернуться. И когда у нас происходит следующий вызов,
# условно, этой функции, здесь работа приостанавливается, когда нам следующее понадобилось из последовательности
# значение какое-то, мы возвращаемся на то место, где мы остановились. Когда мы доходим до конца, ну, просто
# функция заканчивается, значение возвращается и таким образом мы понимаем, что наш iterable исчерпан.

# Главное, что нужно понимать — что, когда мы yield вызываем, мы возвращаем в этот момент значение
# и потом продолжаем выполнять со следующей строки. Такая функция называется генератором. Она генерирует iterable,
# итерируемую последовательность.

# В принципе, такие функции могут быть очень сложными. То есть вы можете с помощью генераторов написать
# какую-нибудь генерацию сложных комбинаторных объектов. Они могут быть рекурсивные, то есть у вас может быть
# несколько вложенных функций, каждая из которых помнит свое состояние с yield.

#  Например, мы хотим вывести квадраты чисел до 10.
def myRange2(n):
    i = 0
    while i < n:
        yield i**2
        i += 1

for i in myRange2(10):
    print(i)

# Как отладить это все? Примерно как рекурсивную функцию. Что делаем? Ставим breakpoint, запускаем
# и смотрим, что у нас происходит.

# В отличие от return при yield никуда не вываливаемся, a просто ходим в функции по шагам


'''В Питоне итераторы - это объекты, которые имеют внутреннее состояние и метод __next__ для перехода 
к следующему состоянию. Например, можно сконструировать итератор от списка и перебрать все значения:'''
myList = [1, 2, 3]
for i in iter(myList):
    print(i)
for i in myList:
    print(i)

'''В этой программе два цикла эквивалентны.

В Питоне можно создавать и свои итераторы. Их разумно использовать в том случае, если нужно перебрать 
большое количество значений и существует правило, по которому можно получить следующее значение, 
однако хранений всех этих значений не имеет смысла, т.к. они пригодятся только один раз.'''

'''Для создания итераторов в Питоне используется специальный вид функций, называемых генераторами. 
В обычной функции return прекращает работу функции. В генераторе вместо return используется оператор yield, 
который также возвращает значение, но не прекращает выполнение функции, а приостанавливает его до тех пор, 
пока не потребуется следующее значение итератора. При этом работа функции продолжится с того места 
и в том состоянии, в котором она находилась на момент вызова yield. Посмотрим, как может быть реализован 
генератор, аналогичный стандартному range с одним параметром:'''
def myRange(n):
    i = 0
    while i < n:
        yield i
        i += 1
for i in myRange(10):
    print(i)

'''Генераторы могут иметь и сложную рекурсивную структуру. Например, мы можем написать генератор, который 
будет выдавать все числа заданной длины, цифры в которых не убывают и старшая цифра не превосходит 
заданного параметра:'''
def genDecDigs(cntDigits, maxDigit):
    if cntDigits > 0:
        for nowDigit in range(maxDigit + 1):
            for tail in genDecDigs(cntDigits - 1, nowDigit):
                yield nowDigit * 10 ** (cntDigits - 1) + tail
    else:
        yield 0

print(*genDecDigs(2, 3))

'''Вывод этой программы будет выглядеть так: 0 10 11 20 21 22 30 31 32 33

В этой программе рекурсивный генератор перебирал все допустимые цифры в качестве той, которая должна 
стоять на заданной позиции и генерировал все возможные последующие цифры.

Также в этой программе мы использовали одну особенность функции print: если переди именем iterable 
(а результат, возвращаемый генератором, является iterable) поставить *, то будут напечатны все значения 
через пробел.

Результат работы генератора можно сохранить, например, в список с помощью функции list, как мы уже делали 
это с результатом работы range.'''

