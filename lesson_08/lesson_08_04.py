# itertools, functools


# Кроме стандартных функций, для работы с последовательностями существуют и некоторые библиотечные функции,
# которые опять же могут облегчить или усложнить нам жизнь в зависимости от того, как ими пользоваться.
# В Python существует две библиотеки, которые содержат что-то полезное для нашего сегодняшнего занятия.
# Это itertools и functools.

import itertools  #  Средства для работы с итераторами
# itertools.

print(*itertools.combinations([1, 2, 3], 2)) # Все подмножества некоторого множества указанной длины
# Чтобы получить вообще все подмножества можно перебрать все размеры

print(*itertools.permutations([1, 2, 3]))  # Все перестановки элементов в лексикографическом порядке

print(*itertools.permutations([1, 2, 3], 2)) # Все перестановки двухэлементных подмножеств

print(*itertools.combinations_with_replacement([1, 2, 3], 2))  # Подмножества с заменой
# Подмножества с повторениями - здесь один и тот же элемент может использоваться дважды


import functools #  Средства для работы с итераторами

functools.partial # Предназначен для задания параметров по умолчанию
# Например, мы хотим печатать часть через пробел и не хотим каждый раз указывать параметр end
prints = functools.partial(print, end=' ') # Первый параметр - функция, которую хотим обернуть, и какие параметры по умолчанию будет
# prints - это обертка над функцией print, у которой параметр end по умолчанию равен пробелу
prints(1)
prints(2)
prints(3)
# Если вы хотите создать над какой-то функцией обертку, где задаются параметры по умолчанию, используйте functools.partial

# Там же есть особый вид partial, который позволяет методы тоже оборачивать. (!!!)

# reduce позволяет последовательно применять некоторую операцию к последовательности.
# Например, мы хотим просуммировать последовательность, не используя сумму.
functools.reduce(lambda x, y: x + y, [1, 2, 3])
# То есть reduce позволяет получать последовательный результат применения функции.
# То есть результат постепенно будет накапливаться


# для накапливания непосредственных результатов с учетом промежуточных есть уже не functools, а основа в itertools.
# Функция accumulate.

import itertools
# Функция accumulate позволяет накапливать промежуточный результат, например, мы хотим узнать
# максимум для каждого префикса последовательностей, то есть для скольки-то первых элементов.
print(*itertools.accumulate([1, 4, 3, 5], max))
# здесь это уже iterable, поэтому звездочка при печати
# Вы накапливаете результат, то есть примерно, как в reduce, последовательно к уже накопленному применяется функция.
# Но если в reduce вы получаете окончательный результат, то в accumulate вы получаете все промежуточные результаты.


# Например, здесь мы узнали максимумы, а в принципе, могли узнавать и, например, суммы считать.
# Мы смогли бы узнавать за одну операцию сумму на каком-то подотрезке нашей последовательности.
# Для этого достаточно было из правого конца накопленной суммы вычесть левый конец − 1.
# И всё, за одно вычитание мы бы узнали сумму на подотрезке.

print(*itertools.accumulate([1, 4, 3, 5], sum))

# Таким образом, используя itertools и functools можно здорово облегчить себе жизнь,
# особенно если вы поставили себе цель писать в функциональном стиле.



# Генерация комбинаторных объектов itertools


'''В Питоне есть библиотека itertools, которая содержит много функций для работы с итераторыми. 
С этими функциями можно ознакомиться в официальной документации к языку.

Нам наиболее интересны функции, генерирующие комбинаторные объекты.'''

'''itertools.combinations(iterable, size) - генерирует все подмножества множества iterable размером size в виде кортежей. 
Это может быть использовано вместо вложенных циклов при организации перебора. Например, мы можем неэффективно решить задачу 
о поиске трех чисел в последовательности, дающих наибольшее произведение:'''

from itertools import combinations

nums = list(map(int, input().split()))
combs = combinations(range(len(nums)), 3)
print(max(map(lambda x: nums[x[0]] * nums[x[1]] * nums[x[2]], combs)))

'''tertools.permutations(iterable) - генерирует все перестановки iterable. Существует вариант функции с двумя параметрами, 
второй параметр является размером подмножества. Тогда генерируются все перестановки всех подмножеств заданного размера.'''

'''itertools.combinations_with_replacement(iterable, size) - генерирует все подмножества iterable размером size 
с повторениями, т.е. одно и то же число можно входить в подмножество несколько раз.'''


'''partial, reduce, accumulate'''

'''Модуль functools содержит некоторые функции, которые могут полезны для обработки последовательностей и не только.

Функция functools.partial предназначена для оберачивания существующих функций с подстановкой некоторых параметров. 
Например, мы можем создать функцию для печати в файл, чтобы каждый раз не указывать какие-то параметры. 
Например, существует вариант функции int с двумя параметрами: первый - это переменная, которую необходимо 
преобразовать в число, а второй - система счисления в которой записано число. С помощью partial мы можем создать 
функцию-обёртку, преобразующую строки из 0 и 1 в числа:'''
from functools import partial

binStrToInt = partial(int, base=2)
print(binStrToInt('10010'))

'''В модуле functools также содержатся функции для обработки последовательностей.

functools.reduce(func, iterable) позволяет применить функцию ко всем элементам последовательности, 
используя в качестве первого аргумента накопленный результат. Например, если в последовательности 
были элементы myList = [A, B, C], то результатом применения reduce(f, myList) будет f(f(A, B), C). 
С помощью reduce, например, можно найти НОД всех чисел в iterable:'''

from functools import reduce

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

print(reduce(gcd, map(int, input().split())))


'''itertools.accumulate(func, iterable), которая возвращает iterable со всеми промежуточными значениями, 
т.е. для списка [A, B, C] accumulate вернет значения A, f(A, B), f(f(A, B), C). Например, можно узнать 
максимальный элемент для каждого префикса (некоторого количества первых элементов) заданной последовательности:'''

from itertools import accumulate

print(*accumulate(map(int, input().split()), max))



# Подробнее о модуле functools:
# https://pythonworld.ru/moduli/modul-functools.html
# http://www.ilnurgi1.ru/docs/python/modules/functools.html

# Подробнее о модуле Модуль itertools:
# https://pythonworld.ru/moduli/modul-itertools.html
# http://www.ilnurgi1.ru/docs/python/modules/itertools.html

