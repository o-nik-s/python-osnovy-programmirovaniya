# Лекция 3: Элементы функционального программирования

# http://www.intuit.ru/studies/courses/49/49/lecture/27062?page=1

# Бинарные операции " + ", " - ", " * ", " / ", которые записываются в выражениях,
# являются "математическими" функциями над двумя аргументами -- операндами. Их используют
# настолько часто, что синтаксис языка программирования имеет для них более короткую запись.
# Модуль operator позволяет представлять эти операции в функциональном стиле:

# Функции являются абстракциями, в которых детали реализации некоторого действия скрываются
# за отдельным именем. Хорошо написанный набор функций позволяет использовать их много раз.

# В Python функции являются объектами (и, значит, могут быть переданы в качестве параметров
# и возвращены в результате выполнения функций).


# Функциональное программирование - это стиль программирования, использующий только композиции функций.
# Другими словами, это программирование в выражениях, а не в императивных командах.

'''Как отмечает Дэвид Мертц (David Mertz) в своей статье о функциональном программировании на Python, 
"функциональное программирование - программирование на функциональных языках (LISP, ML, OCAML, Haskell, ...)", 
основными атрибутами которых являются:
- Наличие функций первого класса" (функции наравне с другими объектами можно передавать внутрь функций).
- Рекурсия является основной управляющей структурой в программе.
- Обработка списков (последовательностей).
- Запрещение побочных эффектов у функций, что в первую очередь означает отсутствие присваивания (в "чистых" функциональных языках)
- Запрещение операторов, основной упор делается на выражения. Вместо операторов вся программа в идеале - 
одно выражение с сопутствующими определениями.
- Ключевой вопрос: что нужно вычислить, а не как.
- Использование функций более высоких порядков (функции над функциями над функциями).'''


# Функциональная программа

'''В математике функция отображает объекты из одного множества (множества определения функции) в другое 
(множество значений функции). Математические функции (их называют чистыми) "механически", однозначно вычисляют результат 
по заданным аргументам. Чистые функции не должны хранить в себе какие-либо данные между двумя вызовами. 
Их можно представлять себе черными ящиками, о которых известно только то, что они делают, но совсем не важно, как.

Программы в функциональном стиле конструируются как композиция функций. При этом функции понимаются почти так же, 
как и в математике: они отображают одни объекты в другие. В программировании "чистые" функции - идеал, не всегда 
достижимый на практике. Практически полезные функции обычно имеют побочный эффект: сохраняют состояние между вызовами 
или меняют состояние других объектов. Например, без побочных эффектов невозможно представить себе функции ввода-вывода. 
Собственно, такие функции ради этих "эффектов" и используются. Кроме того, математические функции легко работают с объектами, 
требующими бесконечного объема информации (например, вещественные числа). В общем случае компьютерная программа может 
выполнить лишь приближенные вычисления.'''

'''Кстати, бинарные операции " + ", " - ", " * ", " / ", которые записываются в выражениях, являются "математическими" 
функциями над двумя аргументами -- операндами. Их используют настолько часто, что синтаксис языка программирования 
имеет для них более короткую запись. Модуль operator позволяет представлять эти операции в функциональном стиле:'''
from operator import add, mul
print(add(2, mul(3, 4)))


# Функция: определение и вызов

'''Определить функцию в Python можно двумя способами: с помощью оператора def и lambda-выражения. Первый способ 
позволяет использовать операторы. При втором - определение функции может быть только выражением.

Можно заметить, что методы классов определяются так же, как и функции. Отличие состоит в специальном смысле 
первого аргумента self (в нем передается экземпляр класса).

Вызов функции синтаксически выглядит как объект-функция(фактические параметры). Обычно объект-функция - 
это просто имя функции, хотя это может быть и любое выражение, которое в результате вычисления дает 
исполняемый объект.'''

'''Пример определения функции с помощью lambda -выражения дан ниже:'''
func = lambda x, y: x + y
'''В результате lambda -выражения получается безымянный объект-функция, которая затем используется, 
например, для того, чтобы связать с ней некоторое имя. Однако, как правило, определяемые lambda-выражением 
функции, применяются в качестве параметров функций.'''

'''В языке Python функция может возвратить только одно значение, которое может быть кортежем.'''

'''Важно понять, что за именем функции стоит объект. Этот объект можно связать с другим именем:'''
def add(x, y):
  return x + y
addition = add  # теперь addition и add - разные имена одного и того же объекта


'''Пример, в котором в качестве значения по умолчанию аргумента функции используется изменчивый объект (список). 
Этот объект - один и тот же для всех вызовов функций, что может привести к казусам:'''
def mylist(val, lst=[]):
  lst.append(val)
  return lst

print mylist(1),
print mylist(2)

'''Вместо ожидаемого [1] [2] получается [1] [1, 2], так как добавляются элементы к "значению по умолчанию".

Правильный вариант решения будет, например, таким:'''
def mylist(val, lst=None):
  lst = lst or []
  lst.append(val)
  return lst

'''Конечно, приведенная выше форма может использоваться для хранения в функции некоторого состояния между ее вызовами, 
однако, практически всегда вместо функции с таким побочным эффектом лучше написать класс и использовать его экземпляр.'''


# Рекурсия

'''В некоторых случаях описание функции элегантнее всего выглядит с применением вызова этой же функции. Такой прием, 
когда функция вызывает саму себя, называется рекурсией. В функциональных языках рекурсия обычно используется много чаще, 
чем итерация (циклы).'''

'''В следующем примере переписывается функция bin() в рекурсивном варианте:'''
def bin(n):
    """Цифры двоичного представления натурального числа """
    if n == 0:
      return []
    n, d = divmod(n, 2)
    return bin(n) + [d]

print bin(69)

'''Здесь видно, что цикл while больше не используется, а вместо него появилось условие окончания рекурсии: 
условие, при выполнении которого функция не вызывает себя.'''

'''Конечно, в погоне за красивым рекурсивным решением не следует упускать из виду эффективность реализации. 
В частности, пример реализации функции для вычисления n -го числа Фибоначчи это демонстрирует:'''
def Fib(n):
   if n < 2:
       return n
   else:
       return Fib(n-1) + Fib(n-2)
'''В данном случае количество рекурсивных вызовов растет экспоненциально от числа n, что совсем не соответствует 
временной сложности решаемой задачи.'''

'''Предупреждение:
При работе с рекурсивными функциями можно легко превысить глубину допустимой в Python рекурсии. Для настройки 
глубины рекурсии следует использовать функцию setrecursionlimit(N) из модуля sys, установив требуемое значение N.'''



# Функции как параметры и результат

'''Функции, принимающие в качестве аргументов или возвращающие другие функции в результате, называют функциями 
высшего порядка. В Python функции высшего порядка применяются программистами достаточно часто. В большинстве случаев 
таким образом строится механизм обратных вызовов (callbacks), но встречаются и другие варианты. Например, алгоритм 
поиска может вызывать переданную ему функцию для каждого найденного объекта.'''



# Обработка последовательностей

'''Многие алгоритмы сводятся к обработке массивов данных и получению новых массивов данных в результате. 
Среди встроенных функций Python есть несколько для работы с последовательностями.

Под последовательностью в Python понимается любой тип данных, который поддерживает интерфейс последовательности 
(это несколько специальных методов, реализующих операции над последовательностями).

Следует заметить, что тип, основной задачей которого является хранение, манипулирование и обеспечение доступа 
к самостоятельным данным называется контейнерным типом или просто контейнером. Примеры контейнеров в Python - списки, 
кортежи, словари.'''


'''Функции range()
Функция range() уже упоминалась при рассмотрении цикла for. Эта функция принимает от одного до трех аргументов. 
Если аргумент всего один, она генерирует список чисел от 0 (включительно) до заданного числа (исключительно). 
Если аргументов два, то список начинается с числа, указанного первым аргументом. Если аргументов три - третий аргумент задает шаг
>>> print range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print range(1, 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print range(1, 10, 3)
[1, 4, 7]'''


'''Функция map()
Для применения некоторой функции ко всем элементам последовательности применяется функция map(f, *args). 
Первый параметр этой функции - функция, которая будет применяться ко всем элементам последовательности. 
Каждый следующий n+1 -й параметр должен быть последовательностью, так как каждый его элемент будет использован 
в качестве n -го параметра при вызове функции f(). Результатом будет список, составленный из результатов 
выполнения этой функции.

В следующем примере складываются значения из двух списков:
>>> l1 = [2, 7, 5, 3]
>>> l2 = [-2, 1, 0, 4]
>>> print map(lambda x, y: x+y, l1, l2)
[0, 8, 5, 7]
В этом примере применена безымянная функция для получения суммы двух операндов ко всем элементам l1 и l2. 
В случае если одна из последовательностей короче другой, вместо соответствующего операнда будет None, что, 
конечно, собьет операцию сложения. В зависимости от решаемой задачи, можно либо видоизменить функцию, 
либо считать разные по длине последовательности ошибкой, которую нужно обрабатывать как отдельную ветвь алгоритма.

Частный случай применения map() - использование None в качестве первого аргумента. В этом случае просто формируется 
список кортежей из элементов исходных последовательностей:
>>> l1 = [2, 7, 5, 3]
>>> l2 = [-2, 1, 0, 4]
>>> print map(None, l1, l2)
[(2, -2), (7, 1), (5, 0), (3, 4)]'''


'''Функция filter()
Другой часто встречающейся операцией является фильтрование исходной последовательности в соответствии 
с некоторым предикатом (условием). Функция filter(f, seq) принимает два аргумента: функцию с условием 
и последовательность, из которой берутся значения. В результирующую последовательность попадут только 
те значения из исходной, для которой f() возвратит истину. Если в качестве f задано значение None, 
результирующая последовательность будет состоять из тех значений исходной, которые имеют истинностное 
значение True.

Например, в следующем фрагменте кода можно избавится от символов, которые не являются буквами:'''
filter(lambda x: x.isalpha(), 'Hi, there! I am eating an apple.')
'HithereIameatinganapple'''


'''Списковые включения
Для более естественной записи обработки списков в Python была внесена новинка: списковые включения. 
Фактически это специальный сокращенный синтаксис для вложенных циклов for и условий if, 
на самом низком уровне которых определенное выражение добавляется к списку, например:'''
all_pairs = []
for i in range(5):
  for j in range(5):
    if i <= j:
      all_pairs.append((i, j))
'''Все это можно записать в виде спискового включения так:'''
all_pairs = [(i, j) for i in range(5) for j in range(5) if i <= j]

'''Как легко заметить, списковые включения позволяют заменить map() и filter() 
на более удобные для прочтения конструкции.'''

'''В следующей таблице приведены эквивалентные выражения в разных формах:
В форме функции	    В форме спискового включения
filter(f, lst)	    [x for x in lst if f(x)]
filter(None, lst)	[x for x in lst if x]
map(f, lst)	        [f(x) for x in lst]'''


'''Функция zip()
Эта функция возвращает список кортежей, в котором i -й кортеж содержит i-е элементы 
аргументов-последовательностей. Длина результирующей последовательности равна длине 
самой короткой из последовательностей-аргументов:'''
print zip(range(5), "abcde")
'''[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e')]'''


# Итераторы

'''Применять для обработки данных явные последовательности не всегда эффективно, так как на хранение 
временных данных может тратиться много оперативной памяти. Более эффективным решением представляется 
использование итераторов - специальных объектов, обеспечивающих последовательный доступ к данным контейнера. 
Если в выражении есть операции с итераторами вместо контейнеров, промежуточные данные не будут требовать 
много места для хранения - ведь они запрашиваются по мере необходимости для вычислений. При обработке данных 
с использованием итераторов память будет требоваться только для исходных данных и результата, да и то 
необязательно вся сразу - ведь данные могут читаться и записываться в файл на диске.

Итераторы можно применять вместо последовательности в операторе for. Более того, внутренне оператор for 
запрашивает от последовательности ее итератор. Объект файлового типа тоже (построчный) итератор, 
что позволяет обрабатывать большие файлы, не считывая их целиком в память.

Там, где требуется итератор, можно использовать последовательность.

Работа с итераторами рассматривается в разделе, посвященном функциональному программированию, 
так как итераторами удобно манипулировать именно в функциональном стиле.

Использовать итератор можно и "вручную". Любой объект, поддерживающий интерфейс итератора, имеет метод next(), 
который при каждом вызове выдает очередное значение итератора. Если больше значений нет, возбуждается исключение 
StopIteration. Для получения итератора по некоторому объекту необходимо прежде применить к этому объекту функцию iter() 
(цикл for делает это автоматически).

В Python имеется модуль itertools, который содержит набор функций, комбинируя которые, можно составлять достаточно 
сложные схемы обработки данных с помощью итераторов. Далее рассматриваются некоторые функции этого модуля.'''


'''Функция iter()
Эта функция имеет два варианта использования. В первом она принимает всего один аргумент, который должен 
"уметь" предоставлять свой итератор. Во втором один из аргументов - функция без аргументов, другой - 
стоповое значение. Итератор вызывает указанную функцию до тех пор, пока та не возвратит стоповое значение. 
Второй вариант встречается много реже первого и обычно внутри метода класса, так как сложно порождать значения 
"на пустом месте":'''
it1 = iter([1, 2, 3, 4, 5])

def forit(mystate=[]):
  if len(mystate) < 3:
    mystate.append(" ")
    return " "

it2 = iter(forit, None)

print([x for x in it1])
print([x for x in it2])

'''Если функция не возвращает значения явно, она возвращает None, что и использовано в примере выше.'''


'''Функция enumerate()
Эта функция создает итератор, нумерующий элементы другого итератора. Результирующий итератор выдает кортежи, 
в которых первый элемент - номер (начиная с нуля), а второй - элемент исходной последовательности:'''
print([x for x in enumerate("abcd")])
'''[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]'''


'''Функция sorted()
Эта функция позволяет создавать итератор, выполняющий сортировку:'''
sorted('avdsdf')
'''['a', 'd', 'd', 'f', 's', 'v']'''


'''Функция chain() позволяет сделать итератор, состоящий из нескольких соединенных последовательно итераторов. 
Итераторы задаются в виде отдельных аргументов. Пример:'''
from itertools import chain
it1 = iter([1,2,3])
it2 = iter([8,9,0])
for i in chain(it1, it2):
    print(i, end=" ")
'''даст в результате
1 2 3 8 9 0'''


'''Функция itertools.repeat()
Функция repeat() строит итератор, повторяющий некоторый объект заданное количество раз:'''
for i in itertools.repeat(1, 4):
    print(i, end=' ')
'''1 1 1 1'''

'''Функция itertools.count()
Бесконечный итератор, дающий целые числа, начиная с заданного:'''
for i in itertools.count(1):
    print(i, end=' ')
    if i > 100:
        break

'''Функция itertools.cycle()
Можно бесконечно повторять и некоторую последовательность (или значения другого итератора) с помощью функции cycle():'''
tango = [1, 2, 3]
for i in itertools.cycle(tango):
    print (i, end=' ')

'''Функции itertools.imap(), itertools.starmap() и itertools.ifilter()
Аналогами map() и filter() в модуле itertools являются imap() и ifilter(). Отличие imap() от map() в том, 
что вместо значения от преждевременно завершившихся итераторов объект None не подставляется. Пример:'''
for i in map(lambda x, y: (x,y), [1,2], [1,2,3]):
    print(i, end=' ')
'''(1, 1) (2, 2) (None, 3)'''

from itertools import imap
for i in imap(lambda x, y: (x,y), [1,2], [1,2,3]):
  print(i, end=' ')
'''(1, 1) (2, 2)'''

# Далее - здесь: http://www.intuit.ru/studies/courses/49/49/lecture/27062?page=6

