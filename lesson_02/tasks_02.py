# Неделя 2


# Логический тип данных и операции
# Условный оператор


# task_02_01 - Максимум из двух
# Напишите программу, которая считывает два целых числа A и B
# и выводит наибольшее значение из них. Числа — целые от 1 до 1000.

A = int(input())
B = int(input())

if A > B:
    print(A)
else:
    print(B)


# task_02_02 - Какое число больше?
#
# Даны два целых числа. Программа должна вывести число 1,
# если первое число больше второго, число 2, если второе больше первого
# или число 0, если они равны.

A = int(input())
B = int(input())

if A > B:
    print(1)
else:
    if A < B:
        print(2)
    else:
        print(0)


# task_02_03 - Максимум трех чисел
#
# Даны три целых числа. Найдите наибольшее из них
# (программа должна вывести ровно одно целое число).
#
# Какое наименьшее число операторов сравнения (>, <, >=, <=)
# необходимо для решения этой задачи?

A = int(input())
B = int(input())
С = int(input())

if A > B:
    if A > С:
        print(A)
    else:
        print(С)
else:
    if B > С:
        print(B)
    else:
        print(С)


# task_02_04 - Високосный год
#
# Дано натуральное число. Требуется определить, является ли год с данным
# номером високосным. Если год является високосным, то выведите YES,
# иначе выведите NO.
# Напомним, что в соответствии с григорианским календарем, год является
# високосным, если его номер кратен 4, но не кратен 100,
# а также если он кратен 400.

year = int(input())

if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
    print("YES")
else:
    print("NO")


# task_02_05 - Ход короля
#
# Шахматный король ходит по горизонтали, вертикали и диагонали,
# но только на 1 клетку. Даны две различные клетки шахматной доски,
# определите, может ли король попасть с первой клетки на вторую одним ходом.
#
# Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер
# столбца и номер строки сначала для первой клетки, потом для второй клетки.
#
# Программа должна вывести YES, если из первой клетки ходом короля можно
# попасть во вторую или NO в противном случае.

cellR1 = int(input())
cellC1 = int(input())
cellR2 = int(input())
cellC2 = int(input())

if abs(cellC1 - cellC2) <= 1 and abs(cellR1 - cellR2) <= 1:
    print("YES")
else:
    print("NO")


# task_02_06 - Квартиры
# В доме несколько подъездов. В каждом подъезде одинаковое количество квартир.
# Квартиры нумеруются подряд, начиная с единицы. Может ли в некотором подъезде
# первая квартира иметь номер x, а последняя – номер y?
#
# Вводятся два натуральных числа x и y (x≤y), не превышающие 10000.
# Выведите слово YES (заглавными латинскими буквами), если такое возможно,
# и NO в противном случае.

x = int(input())
y = int(input())

quant = y - x + 1
if (x - 1) % quant == 0 and y % quant == 0:
    print("YES")
else:
    print("NO")


# task_02_07 - Цвет клеток шахматной доски

# Заданы две клетки шахматной доски. Если они покрашены в один цвет,
# то выведите слово YES, а если в разные цвета – то NO.

cellR1 = int(input())
cellC1 = int(input())
cellR2 = int(input())
cellC2 = int(input())

if (cellR1 + cellC1 + cellR2 + cellC2) % 2 == 0:
    print("YES")
else:
    print("NO")


# task_02_08 - Шоколадка

# Шоколадка имеет вид прямоугольника, разделенного на n×m долек.
# Шоколадку можно один раз разломить по прямой на две части.
# Определите, можно ли таким образом отломить от шоколадки ровно k долек.
#
# Программа получает на вход три числа: n, m, k.
#
# Программа должна вывести одно из двух слов: YES или NO.

n = int(input())
m = int(input())
k = int(input())

# if n <= 0 or m <= 0 or k <= 0 or n * m == k:
#    print("NO")
# else:
#    if k % n == 0 or k % m == 0:
#        print("YES")
#    else:
#        print("NO")

if n <= 0 or m <= 0 or k < 0 or k >= m * n:
    print("NO")
elif k % n == 0 or k % m == 0:
    print("YES")
else:
    print("NO")


# task_02_09 - Коровы

# Для данного числа n<100 закончите фразу “На лугу пасется...”
# одним из возможных продолжений: “n коров”, “n корова”, “n коровы”,
# правильно склоняя слово “корова”.
#
# Вводится натуральное число.
#
# Программа должна вывести введенное число n и одно из слов: korov, korova
# или korovy. Между числом и словом должен стоять ровно один пробел.

# 1, 21, 31, ... - korova
# 2, 3, 4; 22, 23, 24 - korovy
# 5, 6, ..., 20; 25, ..., 30; ... - korov

n = int(input())

print(n, end=" ")
if 11 <= n <= 20:
    print("korov")
else:
    if n % 10 == 1:
        print("korova")
    else:
        if 2 <= n % 10 <= 4:
            print("korovy")
        else:
            print("korov")

print(n, "korov", end="")
if n % 10 == 1 and n != 11:
    print("a")
if 2 <= n % 10 <= 4 and not(11 <= n <= 20):
    print("y")


# task_02_10 - Знак числа

# В математике функция sign(x) (знак числа) определена так:
# sign(x)=1, если x>0,
# sign(x)=-1, если x<0,
# sign(x)=0, если x=0.
# Для данного числа x выведите значение sign(x).

x = int(input())
if x > 0:
    print(1)
elif x < 0:
    print(-1)
else:
    print(0)


# task_02_11 - Координатные четверти

# Даны координаты двух точек на плоскости, требуется определить, лежат ли они
# в одной координатной четверти или нет (все координаты отличны от нуля).
#
# Вводятся 4 числа:
# координаты первой точки (x1, y1) и координаты второй точки (x2, y2).
#
# Программа должна вывести слово YES, если точки находятся
# в одной координатной четверти, в противном случае вывести слово NO.

x1 = int(input())
y1 = int(input())
x2 = int(input())
y2 = int(input())

if x1 * x2 >= 0 and y1 * y2 >= 0:
    print("YES")
else:
    print("NO")


# task_02_12 - Шашки

# На доске стоит белая шашка. Требуется определить, может ли она попасть
# в заданную клетку, делая ходы по правилам (не превращаясь в дамку).
# Белые шашки могут ходить по черным клеткам по диагонали вверх-влево
# или вверх-вправо. Ходов может быть несколько!
#
# Вводится клетка, где стоит шашка, а затем клетка, куда шашка должна попасть.
#
# Каждая клетка описывается номером вертикали, а затем номером горизонтали.
#
# Выведите слово YES (заглавными буквами), если шашка может попасть
# из начальной клетки в указанную, и NO в противном случае.
#
# Доска имеет размер 8x8, вертикали и горизонтали нумеруются числами от 1 до
# 8, начиная с левого нижнего угла. Исходная и конечная клетки не совпадают.

cellX1 = int(input())
cellY1 = int(input())
cellX2 = int(input())
cellY2 = int(input())

if cellY2 >= cellY1 and cellY2 - cellY1 >= abs(cellX2 - cellX1) \
        and (cellX2 + cellY2) % 2 == 0:
    print("YES")
else:
    print("NO")


# task_02_13 - Тип треугольника

# Даны три стороны треугольника a,b,c. Определите тип треугольника
# с заданными сторонами. Выведите одно из четырех слов:
# rectangular для прямоугольного треугольника,
# acute для остроугольного треугольника,
# obtuse для тупоугольного треугольника
# или impossible, если треугольника с такими сторонами не существует.

a = int(input())
b = int(input())
c = int(input())

if a <= 0 or b <= 0 or c <= 0 or a + b == c or a + c == b or b + c == a:
    print("impossible")
elif a**2 + b**2 == c**2 or a**2 + c**2 == b**2 or b**2 + c**2 == a**2:
    print("rectangular")
elif a**2 + b**2 < c**2 or a**2 + c**2 < b**2 or b**2 + c**2 < a**2:
    print("obtuse")
else:
    print("acute")


# task_02_14 - Четные и нечетные

# Даны три целых числа A, B, C. Определить, есть ли среди них
# хотя бы одно четное и хотя бы одно нечетное.
#
# Формат ввода
# Числа A, B, C, не превышающие по модулю 10000.
#
# Формат вывода
# Одна строка – "YES" или "NO".

A = int(input())
B = int(input())
C = int(input())

if (A % 2 == 0 and B % 2 == 0 and C % 2 == 0) \
        or (A % 2 != 0 and B % 2 != 0 and C % 2 != 0):
    print("NO")
else:
    print("YES")


# task_02_15 - Упорядочить три числа

# Дано три числа. Упорядочите их в порядке неубывания. Программа должна
# считывать три числа a,b,c, затем программа должна менять их значения так,
# чтобы стали выполнены условия a≤b≤c, затем программа выводит тройку a,b,c.
#
# Дополнительные ограничения: нельзя использовать дополнительные переменные
# (то есть единственной допустимой операцией присваивания является обмен
# значений двух переменных типа (a, b) = (b, a).

a = int(input())
b = int(input())
c = int(input())
# (a, b) = (b, a)  # Обмен значений перменных
if b > c:
    (b, c) = (c, b)
if a > b:
    (a, b) = (b, a)
if b > c:
    (b, c) = (c, b)
print(a, b, c)


# task_02_16 - Сколько совпадает чисел
#
# Даны три целых числа. Определите, сколько среди них совпадающих.
# Программа должна вывести одно из чисел: 3 (если все совпадают),
# 2 (если два совпадает) или 0 (если все числа различны).

a = int(input())
b = int(input())
c = int(input())
count = 0
if a == b:
    count = 2
    if a == c:
        count = 3
elif b == c or a == c:
    count = 2
print(count)


# task_02_17 - Узник замка Иф

# За многие годы заточения узник замка Иф проделал в стене прямоугольное
# отверстие размером D×E. Замок Иф сложен из кирпичей, размером A×B×C.
# Определите, сможет ли узник выбрасывать кирпичи в море через это отверстие,
# если стороны кирпича должны быть параллельны сторонам отверстия.
#
# Программа получает на вход числа A,B,C,D,E.
#
# Программа должна вывести слово YES или NO.

A = int(input())
B = int(input())
C = int(input())
D = int(input())
E = int(input())

if B > C:
    (B, C) = (C, B)
if A > B:
    (A, B) = (B, A)
if B > C:
    (B, C) = (C, B)
# print(A, B, C)

if D > E:
    (D, E) = (E, D)
# print(D, E)

if A <= D and B <= E:
    print("YES")
else:
    print("NO")


# task_02_18 - Коробки

# Есть две коробки, первая размером A₁×B₁×C₁, вторая размером A₂×B₂×C₂.
# Определите, можно ли разместить одну из этих коробок внутри другой,
# при условии, что поворачивать коробки можно только на 90 градусов
# вокруг ребер.
#
# Программа получает на вход числа A₁,B₁,C₁,A₂,B₂,C₂.
#
# Программа должна вывести одну из следующих строчек:
# Boxes are equal, если коробки одинаковые,
# The first box is smaller than the second one,
# если первая коробка может быть положена во вторую,
# The first box is larger than the second one,
# если вторая коробка может быть положена в первую,
# Boxes are incomparable, во всех остальных случаях.

A1 = int(input())
B1 = int(input())
C1 = int(input())
A2 = int(input())
B2 = int(input())
C2 = int(input())

if B1 > C1:
    (B1, C1) = (C1, B1)
if A1 > B1:
    (A1, B1) = (B1, A1)
if B1 > C1:
    (B1, C1) = (C1, B1)

if B2 > C2:
    (B2, C2) = (C2, B2)
if A2 > B2:
    (A2, B2) = (B2, A2)
if B2 > C2:
    (B2, C2) = (C2, B2)

if A1 == A2 and B1 == B2 and C1 == C2:
    print("Boxes are equal")
elif A1 <= A2 and B1 <= B2 and C1 <= C2:
    print("The first box is smaller than the second one")
elif A1 >= A2 and B1 >= B2 and C1 >= C2:
    print("The first box is larger than the second one")
else:
    print("Boxes are incomparable")


# task_02_19 - Складирование ноутбуков

# На склад, который имеет форму прямоугольного параллелепипеда,
# привезли ноутбуки, упакованные в коробки. Каждая коробка также имеет форму
# прямоугольного параллелепипеда. По правилам хранения коробки с ноутбуками
# должны быть размещены на складе с выполнением следующих двух условий:
#
# Стороны коробок должны быть параллельны сторонам склада.
# Коробку при помещении на склад разрешается расположить где угодно
# (с выполнением предыдущего условия), в том числе на другой коробке,
# но все коробки должны быть ориентированы одинаково (т.е. нельзя одну коробку
# расположить “стоя”, а другую —“лежа”).
# Напишите программу, которая по размерам склада и размерам коробки
# с ноутбуком определит максимальное количество ноутбуков,
# которое может быть размещено на складе.
#
# Программа получает на вход шесть натуральных чисел. Первые три задают длину,
# высоту и ширину склада. Следующие три задают соответственно
# длину, высоту и ширину коробки с ноутбуком.
#
# Программа должна вывести одно число — максимальное количество ноутбуков,
# которое может быть размещено на складе.

A1 = int(input())
B1 = int(input())
C1 = int(input())
a1 = int(input())
b1 = int(input())
c1 = int(input())

aInA = A1 // a1
aInB = B1 // a1
aInC = C1 // a1
bInA = A1 // b1
bInB = B1 // b1
bInC = C1 // b1
cInA = A1 // c1
cInB = B1 // c1
cInC = C1 // c1

abc = aInA * bInB * cInC
acb = aInA * cInB * bInC
bac = bInA * aInB * cInC
bca = bInA * cInB * aInC
cab = cInA * aInB * bInC
cba = cInA * bInB * aInC

max = abc
if max < acb:
    max = acb
if max < bac:
    max = bac
if max < bca:
    max = bca
if max < cab:
    max = cab
if max < cba:
    max = cba

print(max)


# task_02_20 - Мороженое

# В кафе мороженое продают по три шарика и по пять шариков.
# Можно ли купить ровно k шариков мороженого?
#
# Вводится число k (целое, положительное).
#
# Программа должна вывести слово YES, если при таких условиях
# можно набрать ровно k шариков (не больше и не меньше),
# в противном случае - вывести NO.

k = int(input())
if k < 3 or k == 4 or k == 7:
    print("NO")
else:
    print("YES")


# task_02_21 - Сложное уравнение*

# Решить в целых числах уравнение: (ax+b) / (cx+d) = 0
#
# Вводятся 4 числа: a,b,c,d; c и d не равны нулю одновременно.
#
# Необходимо вывести все решения, если их число конечно, “NO” (без кавычек),
# если решений нет, и “INF” (без кавычек), если решений бесконечно много.

a = int(input())
b = int(input())
c = int(input())
d = int(input())

if a == 0 and b == 0:
    print("INF")
elif a == 0 or (c != 0 and -b / a == -d / c):
    print("NO")
elif -b % a == 0:
    print(int(-b / a))
else:
    print("NO")


# task_02_22 - Котлеты*

# На сковородку одновременно можно положить k котлет. Каждую котлету нужно
# с каждой стороны обжаривать m минут непрерывно. За какое наименьшее время
# удастся поджарить с обеих сторон n котлет?
#
# Программа получает на вход три числа: k, m, n.
#
# Программа должна вывести одно число: наименьшее количество минут.

k = int(input())
m = int(input())
n = int(input())

# 2 * n - сторон /жарки/
# k котлет за раз /m минут/
# (2 * n) // k - сковородок
if k >= n:
    print(2 * m)
else:
    print(int((2 * n - 0.01) // k + 1) * m)


# Спички*

# Вдоль прямой выложены три спички. Необходимо переложить одну из них так,
# чтобы при поджигании любой спички сгорали все три. Для того чтобы огонь
# переходил с одной спички на другую, необходимо чтобы эти спички
# соприкасались (хотя бы концами).
#
# Требуется написать программу, определяющую, какую из трех спичек
# необходимо переместить.
#
# Вводятся шесть целых чисел : l₁,r₁,l₂,r₂,l₃,r₃ –– координаты первой, второй
# и третьей спичек соответственно (0 ≤ lᵢ < rᵢ ≤ 100). Каждая спичка
# описывается координатами левого и правого концов по горизонтальной оси OX.
#
# Выведите номер искомой спички. Если возможных ответов несколько, то выведите
# наименьший из них. В случае, когда нет необходимости перемещать какую-либо
# спичку, выведите 0. Если же требуемого результата достигнуть невозможно,
# то выведите -1.

l1 = int(input())
r1 = int(input())
l2 = int(input())
r2 = int(input())
l3 = int(input())
r3 = int(input())

# answer = start1 <= finish2 and start2 <= finish1

cross12 = l1 <= r2 and l2 <= r1
cross13 = l1 <= r3 and l3 <= r1
cross23 = l2 <= r3 and l3 <= r2

len1 = r1 - l1
len2 = r2 - l2
len3 = r3 - l3

if cross12 and cross13 and cross23:
    print(0)
elif cross12 and (cross13 or cross23):
    print(0)
elif cross13 and cross23:
    print(0)
elif cross23:
    print(1)
elif abs(l2 - r3) <= len1 or abs(l3 - r2) <= len1:
    print(1)
elif cross13:
    print(2)
elif abs(l1 - r3) <= len2 or abs(l3 - r1) <= len2:
    print(2)
elif cross12:
    print(3)
elif abs(l1 - r2) <= len3 or abs(l2 - r1) <= len3:
    print(3)
else:
    print(-1)


# task_02_24 - Упаковка*

# В одну транспортную компанию поступил заказ на перевозку двух ящиков
# из одного города в другой. Для перевозки ящики решено было
# упаковать в специальный контейнер.
#
# Ящики и контейнер имеют вид прямоугольных параллелепипедов. Длина, ширина и
# высота первого ящика — l₁,w₁ и h₁, соответствующие размеры второго ящика –
# l₂,w₂ и h₂. Контейнер имеет длину, ширину и высоту lc,wc и hc.
#
# Поскольку ящики содержат хрупкое оборудование, после упаковки в контейнер
# каждый из них должен остаться в строго вертикальном положении. Таким
# образом, ящики можно разместить рядом или один на другом. Для надежного
# закрепления в контейнере стороны ящиков должны быть параллельны его
# сторонам. Иначе говоря, если исходно ящики были расположены так, что все их
# стороны параллельны соответствующим сторонам контейнера, то каждый из них
# разрешается перемещать и поворачивать относительно вертикальной оси на угол,
# кратный 90 градусам.
#
# Разумеется, после упаковки оба ящика должны полностью находиться внутри
# контейнера и не должны пересекаться.
#
# Выясните, можно ли поместить ящики в контейнер с соблюдением указанных
# условий.
#
# Во входных данных записаны числа l₁, w₁, h₁, l₂,w₂, h₂, lc, wc и hc. Все
# размеры — целые положительные числа, не превышающие 1000. Числа в строках
# разделены пробелами.

l1 = int(input())
w1 = int(input())
h1 = int(input())
l2 = int(input())
w2 = int(input())
h2 = int(input())
lc = int(input())
wc = int(input())
hc = int(input())

if lc <= wc:
    (lc, wc) = (wc, lc)  # Длина больше ширины
if l1 <= w1:
    (l1, w1) = (w1, l1)
if l2 <= w2:
    (l2, w2) = (w2, l2)
if l2 <= l1:
    (l1, l2) = (l2, l1)  # Длина второй коробки больше длины первой коробки

if h1 > hc or h2 > hc:
    print("NO")
elif h1 + h2 <= hc:
    print("YES")
else:
    wt = w1 + w2
    if wt > l2:
        if wt <= lc and l2 <= wc:
            print("YES")
        else:
            print("NO")
    else:
        if l2 <= lc and wt <= wc:
            print("YES")
        else:
            print("NO")


# task_02_25 - Список квадратов

# По данному целому числу N распечатайте все квадраты натуральных чисел,
# не превосходящие N, в порядке возрастания.

N = int(input())

i = 1
while i ** 2 <= N:
    print(i ** 2)
    i = i + 1


# task_02_26 - Минимальный делитель

# Дано целое число, не меньшее 2. Выведите его наименьший натуральный
# делитель, отличный от 1.

N = int(input())

k = 2
while N % k != 0:
    k = k + 1
print(k)


# task_02_27 - Список степеней двойки

# По данному числу N распечатайте все целые степени двойки,
# не превосходящие N, в порядке возрастания.Операцией возведения в степень
# пользоваться нельзя!

N = int(input())

k = 1
while k <= N:
    print(k)
    k = 2 * k


# task_02_28 - Точная степень двойки

# Дано натуральное число N. Выведите слово YES, если число N является
# точной степенью двойки, или слово NO в противном случае. Операцией
# возведения в степень пользоваться нельзя!

N = int(input())

k = 1
while k < N:
    k = 2 * k
else:
    if k == N:
        print("YES")
    else:
        print("NO")


# task_02_29 - Двоичный логарифм

# По данному натуральному числу N выведите такое наименьшее целое число k,
# что 2ᵏ≥N. Операцией возведения в степень пользоваться нельзя!

N = int(input())

i = 0
k = 1
while k < N:
    i += 1
    k = 2 * k
print(i)


# task_02_30 - Утренняя пробежка

# В первый день спортсмен пробежал x километров, а затем он каждый день
# увеличивал пробег на 10% от предыдущего значения. По данному числу y
# определите номер дня, на который пробег спортсмена составит не менее y
# километров.

x = int(input())
y = int(input())

d = 1
s = x
while s < y:
    d = d + 1
    s = s * 1.1
print(d)


# task_02_31 - Максимум последовательности

# Последовательность состоит из натуральных чисел, не превосходящих 10⁹,
# и завершается числом 0. Определите значение наибольшего элемента
# последовательности.
#
# Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число
# 0 в последовательность не входит, а служит как признак ее окончания).
#
# Выведите ответ на задачу.

N = int(input())
maxN = 0
while N != 0:
    if maxN < N:
        maxN = N
    N = int(input())
print(maxN)


# task_02_32 - Сумма квадратов

# По данному натуральном n вычислите сумму 1²+2²+3²+...+n².

# n = int(input("Введите натуральное n: "))
n = int(input())

sumSquare = 0
i = 1
while i <= n:
    sumSquare += i**2
    i += 1
# print("Сумма квадратов равна:", sumSquare)
print(sumSquare)


# task_02_33 - Длина последовательности

# Программа получает на вход последовательность целых неотрицательных чисел,
# каждое число записано в отдельной строке. Последовательность завершается
# числом 0, при считывании которого программа должна закончить свою работу
# и вывести количество членов последовательности
# (не считая завершающего числа 0).
#
# Числа, следующие за числом 0, считывать не нужно.

n = int(input())
count = 0
while n != 0:
    count += 1
    n = int(input())
print(count)


# task_02_34 - Сумма последовательности

# Определите сумму всех элементов последовательности, завершающейся числом 0.
#
# Вводится последовательность целых чисел, оканчивающаяся числом 0 (само
# число 0 в последовательность не входит, а служит как признак ее окончания).

n = int(input())
sumSeq = 0
while n != 0:
    sumSeq += n
    n = int(input())
print(sumSeq)


# task_02_35 - Среднее значение последовательности

# Определите среднее значение всех элементов последовательности,
# завершающейся числом 0. Использовать массивы в данной задаче нельзя.
#
# Вводится последовательность целых чисел, оканчивающаяся числом 0
# (само число 0 в последовательность не входит, а служит как признак
# ее окончания.
# Выведите ответ на задачу.

n = int(input())
mean = 0
i = 0
while n != 0:
    mean += n
    i += 1
    n = int(input())
mean /= i
print(mean)


# task_02_37 - Количество четных элементов последовательности

# Определите количество четных элементов в последовательности,
# завершающейся числом 0.

n = int(input())
countEvenElem = 0
while n != 0:
    if n % 2 == 0:
        countEvenElem += 1
    n = int(input())
print(countEvenElem)


# task_02_38 - Второй максимум

# Последовательность состоит из натуральных чисел и завершается числом 0.
# Определите значение второго по величине элемента в этой последовательности,
# то есть элемента, который будет наибольшим, если из последовательности
# удалить одно вхождение наибольшего элемента.

n = int(input())
k1 = 0
k2 = 0
while n != 0:
    if n > k1:
        k2 = k1
        k1 = n
    elif n > k2:
        k2 = n
    n = int(input())
print(k2)


# task_02_39 - Количество элементов, равных максимуму

# Последовательность состоит из натуральных чисел и завершается числом 0.
# Определите, какое количество элементов этой последовательности,
# равны ее наибольшему элементу.
#
# Вводится последовательность целых чисел, оканчивающаяся числом 0 (само
# число 0 в последовательность не входит, а служит как признак ее окончания).
# Выведите ответ на задачу.

n = int(input())
max = 0
count = 0
while n != 0:
    if n > max:
        max = n
        count = 1
    elif n == max:
        count += 1
    n = int(input())
print(count)


# task_02_40 - Числа Фибоначчи

# Последовательность Фибоначчи определяется так:
# F[0] = 0, F[1] = 1, ..., F[n] = F[n-1] + F[n-2].
# По данному числу n определите n-е число Фибоначчи F[n].

n = int(input())
if n == 0:
    Fn = 0
elif n == 1:
    Fn = 1
else:
    i = 2
    Fn1 = 0
    Fn2 = 1
    Fn = 1
    while i <= n:
        (Fn, Fn1, Fn2) = (Fn + Fn1, Fn, Fn1)
        i = i + 1
print(Fn)


# task_02_41 - Номер числа Фибоначчи

# Последовательность Фибоначчи определяется так:
# F[0]=0, F[1]=1, ..., F[n]=F[n-1]+F[n-2].
# Дано натуральное число A. Определите, каким по счету числом Фибоначчи
# оно является, то есть выведите такое число n, что F[n]=A.
# Если А не является числом Фибоначчи,выведите число -1.

A = int(input())
if A == 0:
    n = 0
elif A == 1:
    n = 1
else:
    i = 2
    Fn_2 = 0
    Fn_1 = 1
    Fn = 1
    while Fn < A:
        # print(i, ":", Fn, Fn_1, Fn_2)
        (Fn, Fn_1, Fn_2) = (Fn + Fn_1, Fn, Fn_1)
        i = i + 1
    else:
        if Fn == A:
            n = i
        else:
            n = -1
print(n)


# task_02_42 - Исполнитель раздвоитель

# Исполнитель “Раздвоитель” преобразует натуральные числа. У него есть
# две команды: “Вычесть 1” и “Разделить на 2”, первая команда уменьшает
# число на 1, вторая команда уменьшает число в два раза, если оно чётное,
# иначе происходит ошибка. Дано два натуральных числа A и B (A > B). Напишите
# алгоритм для Развоителя, который преобразует число A в число B и при этом
# содержит минимальное число команд. Команды алгоритма нужно выводить поодной
# в строке, первая команда обозначается, как -1, вторая команда как :2.

A = int(input())
B = int(input())

while A > B:
    if A % 2 == 0 and A / 2 >= B:
        print(":2")
        A /= 2
    else:
        print("-1")
        A -= 1


# task_02_43 - Обращение числа

# Переставьте цифры числа в обратном порядке.
#
# Задано единственное число N.
# Необходимо вывести цифры данного числа в обратном порядке.

N = int(input())
n = 0
while N // 10 > 0:
    n = 10 * n + (N % 10)
    N = N // 10
n = 10 * n + (N % 10)
print(n)


# task_02_44 - Количество палиндромов

# Назовем число палиндромом, если оно не меняется при перестановке его цифр
# в обратном порядке. Напишите программу, которая по заданному числу K выводит
# количество натуральных палиндромов, не превосходящих K.
#
# Задано единственное число K (1≤K≤100000).
#
# Необходимо вывести количество натуральных палиндромов, не превосходящих K.

K = int(input())
L = 1  # Текущее число для проверки
n = 0  # Количество палиндромов
while L <= K:
    M = L  # Будем проверять на палиндром
    m = 0  # Оборачиваем M в L
    while M // 10 > 0:
        m = 10 * m + (M % 10)
        M = M // 10
    m = 10 * m + (M % 10)
    # print(L, M, m)
    if m == L:  # Если палиндром
        n += 1
    L += 1
print(n)


# task_02_45 - Максимальное число подряд идущих равных

# Дана последовательность натуральных чисел, завершающаяся числом 0.
# Определите, какое наибольшее число подряд идущих элементов этой
# последовательности равны друг другу.

n = int(input())
m = 0
k = 1
maxk = 0  # Максимальное количество идущих подряд равных элементов
while n != 0:
    if m == n:
        k += 1
    else:
        k = 1
    m = n
    if maxk < k:
        maxk = k
    n = int(input())
print(maxk)


# task_02_46 - Максимальная длина монотонного фрагмента

# Дана последовательность натуральных чисел, завершающаяся число 0. Определите
# наибольшую длину монотонного фрагмента последовательности (то есть такого
# фрагмента, где все элементы либо больше предыдущего, либо меньше).

n = int(input())
m = 0
k = 0
maxk = 0  # Максимальная длина монотонного фрамгента
sign = 0
while n != 0:
    if m == n:
        sign = 0
    elif m < n:
        if sign < 0:
            k = 1
        elif sign > 0:
            k += 1
            # print(m, k)
        sign = 1
    elif m > n:
        if sign > 0:
            k = 1
        elif sign < 0:
            k += 1
        sign = -1
    else:
        k = 1
    m = n
    if maxk < k + 1:
        maxk = k + 1  # Учитываем последний элемент в последовательности
    n = int(input())
print(maxk)


# task_02_47 - Наименьшее расстояние между локальными максимумами

# Определите наименьшее расстояние между двумя локальными максимумами
# последовательности натуральных чисел, завершающейся числом 0. Локальным
# максимумом называется такое число в последовательности, которое больше
# своих соседей. Если в последовательности нет двух локальных максимумов,
# выведите число 0. Начальное и конечное значение при этом локальными
# максимумами не считаются.

n = int(input())
length = 0
locMax = n
sign = 0
nLocMax = 0
dist = 0  # Расстояние между локальными максимумами
k = 0  # Номер в последовательности локального максимума
while n != 0:
    if n > locMax:
        locMax = n
        sign = 1
    elif n == locMax:
        sign = 0
    elif n < locMax:
        if sign == 1:
            # print("Новый локальный максимум", locMax, "на позиции", k)
            if nLocMax > 0 and (dist == 0 or k - nLocMax < dist):
                dist = k - nLocMax
                # print("Новая дистанция между локальными максимумами:", dist)
            nLocMax = k
        locMax = n
        sign = -1
    n = int(input())
    k += 1
print(dist)
